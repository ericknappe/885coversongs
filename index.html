<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WXPN 885 Greatest Cover Songs – Countdown Dashboard</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 6px 0 2px;
      text-align: center;
    }
    header h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
      color: #f5f5f5;
    }
    #controls {
      padding: 4px 0 8px;
      background: #111;
      display: flex;
      justify-content: center;
    }
    #controls-inner {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #eee;
      max-width: 700px;
      width: 100%;
      padding: 4px 12px;
      border-radius: 999px;
      background: #222;
      border: 1px solid #333;
    }
    #controls-inner label {
      white-space: nowrap;
      font-size: 13px;
    }
    #frameSlider {
      flex: 1;
    }
    #frameLabel {
      min-width: 60px;
      text-align: right;
      font-variant-numeric: tabular-nums;
      font-size: 13px;
    }

    #dashboard {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-auto-rows: minmax(0, 1fr);
      gap: 6px;
      padding: 6px;
    }
    @media (max-width: 1200px) {
      #dashboard {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    @media (max-width: 800px) {
      #dashboard {
        grid-template-columns: 1fr;
      }
    }

    .cell {
      background: #181818;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 4px 5px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      cursor: move;
    }

    .cell-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 2px;
    }
    .cell-title {
      flex: 1;
      font-size: 13px;
      font-weight: 600;
      color: #f0f0f0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: center;
    }
    .cell-toggle {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #444;
      background: #262626;
      color: #eee;
      cursor: pointer;
    }
    .cell-toggle:hover {
      background: #333;
    }

    .cell-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    #cell7 {
      display: none !important;
    }

    .chart-container {
      flex: 1;
      position: relative;
      min-height: 0;
    }
    svg.chart {
      width: 100%;
      height: 100%;
      display: block;
    }

    #current-song {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      gap: 8px;
    }

    #current-song img {
      max-width: 80%;
      height: 220px;          /* fixed height to avoid layout jumps */
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0,0,0,0.7);
      object-fit: cover;
      background: #000;
      transition: opacity 0.2s ease-in-out;
    }
    #current-song img.no-art {
      opacity: 0;
      box-shadow: none;
    }

    #current-song .song-title {
      font-size: 15px;
      font-weight: 600;
    }
    #current-song .song-artist {
      font-size: 14px;
      color: #ccc;
    }
    #current-song .song-meta {
      font-size: 13px;
      color: #aaa;
    }

    .dragging {
      opacity: 0.6;
      outline: 2px dashed #888;
    }

    @media (pointer: coarse) {
      .cell {
        cursor: default;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>WXPN 885 Greatest Cover Songs – Countdown Dashboard</h1>
  </header>

  <div id="controls">
    <div id="controls-inner">
      <label for="frameSlider">Song number:</label>
      <input type="range" id="frameSlider" min="0" max="0" value="0" />
      <div id="frameLabel">0</div>
    </div>
  </div>

  <div id="dashboard">
    <div class="cell draggable-cell" id="cell1">
      <div class="cell-header">
        <span class="cell-title">Most Covered Original Artists</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div class="chart-container"><svg class="chart" id="chart-orig-artists"></svg></div>
      </div>
    </div>

    <div class="cell draggable-cell" id="cell2">
      <div class="cell-header">
        <span class="cell-title">Most Frequent Cover Artists</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div class="chart-container"><svg class="chart" id="chart-cover-artists"></svg></div>
      </div>
    </div>

    <div class="cell draggable-cell" id="cell3">
      <div class="cell-header">
        <span class="cell-title">Most Represented Genres</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div class="chart-container"><svg class="chart" id="chart-genres"></svg></div>
      </div>
    </div>

    <div class="cell draggable-cell" id="cell4">
      <div class="cell-header">
        <span class="cell-title">Most Covered Original Songs</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div class="chart-container"><svg class="chart" id="chart-orig-songs"></svg></div>
      </div>
    </div>

    <div class="cell draggable-cell" id="cell5">
      <div class="cell-header">
        <span class="cell-title">Most Covered Original Decades</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div class="chart-container"><svg class="chart" id="chart-orig-decades"></svg></div>
      </div>
    </div>

    <div class="cell draggable-cell" id="cell6">
      <div class="cell-header">
        <span class="cell-title">Current Song</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div id="current-song">
          <img id="current-album-art" src="" alt="" class="no-art" />
          <div class="song-title" id="current-song-title">Loading…</div>
          <div class="song-artist" id="current-song-artist"></div>
          <div class="song-meta" id="current-song-meta"></div>
        </div>
      </div>
    </div>

    <!-- Slot 7: Cover years chart, hidden by default -->
    <div class="cell draggable-cell" id="cell7">
      <div class="cell-header">
        <span class="cell-title">Most Frequent Cover Years</span>
        <button class="cell-toggle" type="button">Show</button>
      </div>
      <div class="cell-body" style="display: none;">
        <div class="chart-container"><svg class="chart" id="chart-cover-years"></svg></div>
      </div>
    </div>
  </div>

  <script>
    // --- Config ---------------------------------------------------------
    const MIN_COUNT_ORIG_ARTIST = 2;
    const MIN_COUNT_COVER_ARTIST = 2;
    const MIN_COUNT_GENRE = 3;
    const MIN_COUNT_ORIG_SONG = 2;
    const MIN_COUNT_DECADE = 2;
    const MIN_COUNT_COVER_YEAR = 2;

    const MIN_DISPLAY_COUNT = 2;
    const MOMENTUM_WINDOW = 20;
    const FAST_RISER_THRESHOLD = 5;

    const TOP_N_ARTISTS = 15;
    const TOP_N_ORIG_SONGS = 15;
    const TOP_N_GENRES = 20;
    const TOP_N_DECADES = 10;
    const TOP_N_YEARS = 15;

    const MAX_LABEL_CHARS = 25;

    const frameSlider = document.getElementById("frameSlider");
    const frameLabel = document.getElementById("frameLabel");
    const currentAlbumArt = document.getElementById("current-album-art");
    const currentSongTitle = document.getElementById("current-song-title");
    const currentSongArtist = document.getElementById("current-song-artist");
    const currentSongMeta = document.getElementById("current-song-meta");

    const urlParams = new URLSearchParams(window.location.search);
    const DATA_ENDPOINT = urlParams.get("data_endpoint") || "https://origin.xpn.org/countdown/2025/json/cd2025.json";

    const BAR_HEIGHT_FACTOR = 1 / 3;

    function truncateLabel(label, maxLen) {
      if (!label) return "";
      if (label.length <= maxLen) return label;
      if (maxLen <= 1) return label.slice(0, maxLen);
      return label.slice(0, maxLen - 1) + "…";
    }

    function cleanLabelText(s) {
      return String(s || "").replace(/\\'/g, "'");
    }

    function parsePhpGenre(value) {
      if (!value || typeof value !== "string") return [];
      if (!value.startsWith("a:")) return [];
      const regex = /s:\d+:"(.*?)"/g;
      const result = [];
      let m;
      while ((m = regex.exec(value)) !== null) {
        result.push(m[1]);
      }
      return result;
    }

    // New, more forgiving year parser for releaseDate
    function parseYearFromString(value) {
      if (value === null || value === undefined) return null;
      const match = String(value).match(/(18|19|20)\d{2}/);
      if (!match) return null;
      const year = parseInt(match[0], 10);
      if (isNaN(year) || year < 1800 || year > 2100) return null;
      return year;
    }

    function computeDecade(year) {
      if (year === null || year === undefined || isNaN(year)) return null;
      const y = parseInt(year, 10);
      const decadeStart = Math.floor(y / 10) * 10;
      return decadeStart + "s";
    }

    function computeGlobalMax(framesCounts, minDisplay) {
      let maxVal = 0;
      framesCounts.forEach(frame => {
        Object.values(frame).forEach(v => {
          if (v != null && v >= minDisplay && v > maxVal) {
            maxVal = v;
          }
        });
      });
      return maxVal;
    }

    function buildMetricTimeSeries(sortedSongs, categoryFn, minCountFinal) {
      const finalCounts = new Map();
      sortedSongs.forEach(row => {
        const cats = categoryFn(row) || [];
        cats.forEach(cat => {
          if (cat === null || cat === undefined || cat === "") return;
          const prev = finalCounts.get(cat) || 0;
          finalCounts.set(cat, prev + 1);
        });
      });

      const allowed = new Set(
        Array.from(finalCounts.entries())
          .filter(([c, cnt]) => cnt >= minCountFinal)
          .map(([c]) => c)
      );

      const frames = [];
      const currentCounts = new Map();
      sortedSongs.forEach(row => {
        const cats = categoryFn(row) || [];
        cats.forEach(cat => {
          if (!allowed.has(cat)) return;
          const prev = currentCounts.get(cat) || 0;
          currentCounts.set(cat, prev + 1);
        });
        const snapshot = {};
        currentCounts.forEach((v, k) => {
          snapshot[k] = v;
        });
        frames.push(snapshot);
      });

      return { frames, allowed };
    }

    function chooseTickStep(maxVal) {
      if (maxVal <= 20) return 2;
      if (maxVal <= 50) return 5;
      if (maxVal <= 250) return 25;
      if (maxVal <= 500) return 50;
      return 100;
    }

    function setupChart(svgElement, topN, globalMax, allowedSet) {
      const svg = d3.select(svgElement);
      svg.selectAll("*").remove();

      const width = svg.node().clientWidth || 400;
      const height = svg.node().clientHeight || 200;

      let marginLeft;
      if (width <= 500) {
        marginLeft = 130;
      } else if (width <= 900) {
        marginLeft = 150;
      } else {
        marginLeft = 165;
      }

      const margin = { top: 4, right: 8, bottom: 18, left: marginLeft };
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      const g = svg
        .attr("viewBox", `0 0 ${width} ${height}`)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      const maxVal = Math.max(globalMax, 2);
      const step = chooseTickStep(maxVal);
      const xMaxRounded = Math.ceil(maxVal / step) * step;

      const xScale = d3.scaleLinear()
        .domain([0, xMaxRounded])
        .range([0, innerWidth]);

      const ticks = d3.range(0, xMaxRounded + step, step);

      const xAxisGrid = d3.axisBottom(xScale)
        .tickValues(ticks)
        .tickSize(-innerHeight)
        .tickFormat("");
      g.append("g")
        .attr("class", "x-grid")
        .attr("transform", `translate(0,${innerHeight})`)
        .call(xAxisGrid)
        .selectAll("line")
        .attr("stroke", "#333")
        .attr("stroke-dasharray", "2,2");

      const xAxis = d3.axisBottom(xScale)
        .tickValues(ticks)
        .tickFormat(d3.format("d"));
      g.append("g")
        .attr("class", "x-axis")
        .attr("transform", `translate(0,${innerHeight})`)
        .call(xAxis)
        .selectAll("text")
        .attr("fill", "#ccc")
        .attr("font-size", 9);

      const slotHeight = innerHeight / topN;
      const barHeight = slotHeight * BAR_HEIGHT_FACTOR;

      const colorRange = d3.schemeTableau10.concat(d3.schemeSet3);
      const domainCats = Array.from(allowedSet).sort((a, b) =>
        String(a).localeCompare(String(b))
      );
      const colorScale = d3.scaleOrdinal(colorRange).domain(domainCats);

      return {
        svg,
        g,
        innerWidth,
        innerHeight,
        xScale,
        slotHeight,
        barHeight,
        topN,
        colorScale
      };
    }

    function updateChart(chart, frameCounts, prevFrameCounts, allowedSet, labelFn, fullLabelFn, options) {
      const {
        slotHeight,
        barHeight,
        xScale,
        g,
        topN,
        colorScale
      } = chart;

      const minDisplay = options.minDisplayCount;
      const fastThreshold = options.fastRiserThreshold;

      const entries = Object.entries(frameCounts || {})
        .filter(([cat, cnt]) => allowedSet.has(cat) && cnt != null && cnt >= minDisplay);

      entries.sort((a, b) => d3.descending(a[1], b[1]));
      const ordered = entries.slice(0, topN);
      const count = ordered.length;

      if (count === 0) {
        g.selectAll("rect.bar").remove();
        g.selectAll("text.y-label").remove();
        return;
      }

      const startSlot = topN - count;
      const slotPositions = d3.range(count).map(i => {
        const slotIndex = startSlot + i;
        return slotIndex * slotHeight + (slotHeight - barHeight) / 2;
      });

      const fastSet = new Set();
      if (prevFrameCounts) {
        ordered.forEach(([cat, val]) => {
          const prevVal = prevFrameCounts[cat] || 0;
          const delta = val - prevVal;
          if (delta >= fastThreshold) fastSet.add(cat);
        });
      }

      const bars = g.selectAll("rect.bar")
        .data(ordered, d => d[0]);

      bars.enter()
        .append("rect")
        .attr("class", "bar")
        .attr("x", 0)
        .attr("y", (d, i) => slotPositions[i])
        .attr("height", barHeight)
        .attr("width", d => xScale(d[1]))
        .attr("fill", d => colorScale(d[0]))
        .merge(bars)
        .attr("y", (d, i) => slotPositions[i])
        .attr("width", d => xScale(d[1]))
        .attr("fill", d => colorScale(d[0]));

      bars.exit().remove();

      const labels = g.selectAll("text.y-label")
        .data(ordered, d => d[0]);

      const labelsEnter = labels.enter()
        .append("text")
        .attr("class", "y-label")
        .attr("x", -6)
        .attr("y", (d, i) => slotPositions[i] + barHeight / 2)
        .attr("dy", "0.35em")
        .attr("text-anchor", "end")
        .attr("alignment-baseline", "middle")
        .attr("fill", "#eee")
        .attr("font-size", 10)
        .text(d => {
          const cat = d[0];
          const base = labelFn(cat);
          const truncated = truncateLabel(base, MAX_LABEL_CHARS);
          return (fastSet.has(cat) ? "↑ " : "") + truncated;
        });

      const labelsMerged = labelsEnter.merge(labels)
        .attr("y", (d, i) => slotPositions[i] + barHeight / 2)
        .text(d => {
          const cat = d[0];
          const base = labelFn(cat);
          const truncated = truncateLabel(base, MAX_LABEL_CHARS);
          return (fastSet.has(cat) ? "↑ " : "") + truncated;
        });

      labels.exit().remove();

      labelsMerged.attr("font-weight", d => {
        const cat = d[0];
        return fastSet.has(cat) ? "bold" : "normal";
      });

      if (typeof fullLabelFn === "function") {
        labelsMerged.each(function(d) {
          const cat = d[0];
          const fullText = fullLabelFn(cat);
          const sel = d3.select(this);
          let title = sel.select("title");
          if (!fullText) {
            if (!title.empty()) title.remove();
            return;
          }
          if (title.empty()) {
            title = sel.append("title");
          }
          title.text(fullText);
        });
      } else {
        labelsMerged.select("title").remove();
      }
    }

    function labelDefault(cat) {
      if (cat === null || cat === undefined || cat === "") return "Unknown";
      return cleanLabelText(cat);
    }
    function labelDecade(cat) {
      if (cat === null || cat === undefined || cat === "") return "Unknown decade";
      return cleanLabelText(cat);
    }

    function initDragAndDrop() {
      const dashboard = document.getElementById("dashboard");
      const finePointer = window.matchMedia && window.matchMedia("(pointer: fine)").matches;
      if (!finePointer) {
        return;
      }

      let dragSrcEl = null;

      dashboard.querySelectorAll(".draggable-cell").forEach(cell => {
        cell.setAttribute("draggable", "true");

        cell.addEventListener("dragstart", e => {
          dragSrcEl = cell;
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/plain", "");
          cell.classList.add("dragging");
        });

        cell.addEventListener("dragend", () => {
          cell.classList.remove("dragging");
        });

        cell.addEventListener("dragover", e => {
          e.preventDefault();
          if (!dragSrcEl || dragSrcEl === cell) return;
          const rect = cell.getBoundingClientRect();
          const offset = e.clientY - rect.top;
          const midpoint = rect.height / 2;
          if (offset > midpoint) {
            dashboard.insertBefore(dragSrcEl, cell.nextSibling);
          } else {
            dashboard.insertBefore(dragSrcEl, cell);
          }
        });
      });
    }

    function initCellToggles() {
      document.querySelectorAll(".cell-toggle").forEach(btn => {
        btn.addEventListener("click", () => {
          const cell = btn.closest(".cell");
          const body = cell.querySelector(".cell-body");
          if (!body) return;
          const isHidden = body.style.display === "none";
          body.style.display = isHidden ? "" : "none";
          btn.textContent = isHidden ? "Hide" : "Show";
        });
      });
    }

    async function init() {
      initCellToggles();
      initDragAndDrop();

      try {
        const resp = await fetch(DATA_ENDPOINT);
        if (!resp.ok) {
          throw new Error(`HTTP ${resp.status}`);
        }
        const data = await resp.json();
        if (!Array.isArray(data)) {
          throw new Error("Data endpoint must return an array");
        }

        const raw = data.map(d => ({ ...d }));
        raw.forEach(row => {
          row.rank = row.rank != null ? Number(row.rank) : null;
          row.genre_list = parsePhpGenre(row.genre);
          row.originalYear_parsed =
            row.originalYear != null ? Number(row.originalYear) : null;
          if (isNaN(row.originalYear_parsed)) row.originalYear_parsed = null;
          row.coverYear_parsed = parseYearFromString(row.releaseDate);
          row.originalDecade = computeDecade(row.originalYear_parsed);

          const song = row.song || null;
          const oa = row.originalArtist || null;
          row.originalSongCombo = (song && oa) ? `${song} — ${oa}` : null;
        });

        const filtered = raw.filter(row => {
          if (row.rank == null || isNaN(row.rank)) return false;
          const hasArtist = row.artist != null && row.artist !== "";
          const hasOrigArtist = row.originalArtist != null && row.originalArtist !== "";
          return hasArtist || hasOrigArtist;
        });

        if (!filtered.length) {
          frameLabel.textContent = "0";
          return;
        }

        const sortedSongs = filtered.slice().sort((a, b) => d3.descending(a.rank, b.rank));
        const frameRanks = sortedSongs.map(row => row.rank);

        const metrics = [
          {
            id: "origArtists",
            svgId: "chart-orig-artists",
            categoryFn: row => (row.originalArtist ? [row.originalArtist] : []),
            minFinal: MIN_COUNT_ORIG_ARTIST,
            topN: TOP_N_ARTISTS,
            labelFn: labelDefault,
            fullLabelFn: null
          },
          {
            id: "coverArtists",
            svgId: "chart-cover-artists",
            categoryFn: row => (row.artist ? [row.artist] : []),
            minFinal: MIN_COUNT_COVER_ARTIST,
            topN: TOP_N_ARTISTS,
            labelFn: labelDefault,
            fullLabelFn: null
          },
          {
            id: "genres",
            svgId: "chart-genres",
            categoryFn: row => row.genre_list || [],
            minFinal: MIN_COUNT_GENRE,
            topN: TOP_N_GENRES,
            labelFn: labelDefault,
            fullLabelFn: null
          },
          {
            id: "origSongs",
            svgId: "chart-orig-songs",
            categoryFn: row => (row.originalSongCombo ? [row.originalSongCombo] : []),
            minFinal: MIN_COUNT_ORIG_SONG,
            topN: TOP_N_ORIG_SONGS,
            labelFn: labelDefault,
            fullLabelFn: (cat) => cleanLabelText(cat)
          },
          {
            id: "origDecades",
            svgId: "chart-orig-decades",
            categoryFn: row => (row.originalDecade ? [row.originalDecade] : []),
            minFinal: MIN_COUNT_DECADE,
            topN: TOP_N_DECADES,
            labelFn: labelDecade,
            fullLabelFn: null
          },
          {
            id: "coverYears",
            svgId: "chart-cover-years",
            categoryFn: row => (row.coverYear_parsed ? [row.coverYear_parsed] : []),
            minFinal: MIN_COUNT_COVER_YEAR,
            topN: TOP_N_YEARS,
            labelFn: labelDefault,
            fullLabelFn: null
          }
        ];

        const metricState = {};

        metrics.forEach(metric => {
          const { frames, allowed } = buildMetricTimeSeries(
            sortedSongs,
            metric.categoryFn,
            metric.minFinal
          );
          const globalMax = computeGlobalMax(frames, MIN_DISPLAY_COUNT);

          const chart = setupChart(
            document.getElementById(metric.svgId),
            metric.topN,
            globalMax,
            allowed
          );

          metricState[metric.id] = {
            frames,
            allowed,
            globalMax,
            chart,
            labelFn: metric.labelFn,
            fullLabelFn: metric.fullLabelFn
          };
        });

        const numFrames = sortedSongs.length;
        frameSlider.min = 0;
        frameSlider.max = numFrames - 1;
        frameSlider.value = 0;

        function updateDashboard(frameIndex) {
          frameIndex = Math.max(0, Math.min(numFrames - 1, frameIndex));
          const rank = frameRanks[frameIndex];
          frameLabel.textContent = rank != null ? String(rank) : "";

          metrics.forEach(metric => {
            const state = metricState[metric.id];
            const frameCounts = state.frames[frameIndex] || {};
            const prevIndex = Math.max(0, frameIndex - MOMENTUM_WINDOW);
            const prevCounts = state.frames[prevIndex] || {};
            updateChart(
              state.chart,
              frameCounts,
              prevCounts,
              state.allowed,
              state.labelFn,
              state.fullLabelFn,
              {
                minDisplayCount: MIN_DISPLAY_COUNT,
                fastRiserThreshold: FAST_RISER_THRESHOLD
              }
            );
          });

          const songRow = sortedSongs[frameIndex];
          const imgUrl = songRow.albumArt || "";

          if (imgUrl) {
            currentAlbumArt.classList.remove("no-art");
            currentAlbumArt.src = imgUrl;
            currentAlbumArt.alt = `${cleanLabelText(songRow.song || "")} – ${cleanLabelText(songRow.artist || "")}`;
          } else {
            currentAlbumArt.classList.add("no-art");
            currentAlbumArt.alt = "";
          }

          const title = cleanLabelText(songRow.song || "(Unknown song)");
          const artist = cleanLabelText(songRow.artist || "(Unknown cover artist)");
          const origArtist = cleanLabelText(songRow.originalArtist || "(Unknown original artist)");
          const origYear = songRow.originalYear_parsed || "Unknown year";
          const coverYear = songRow.coverYear_parsed || "Unknown cover year";

          currentSongTitle.textContent = title;
          currentSongArtist.textContent = `${artist} (covering ${origArtist})`;
          currentSongMeta.textContent =
            `Rank ${songRow.rank} · Original year: ${origYear} · Cover year: ${coverYear}`;
        }

        frameSlider.addEventListener("input", e => {
          const idx = Number(e.target.value) || 0;
          updateDashboard(idx);
        });

        updateDashboard(0);
      } catch (err) {
        console.error(err);
        frameLabel.textContent = "0";
      }
    }

    init();
  </script>
</body>
</html>
