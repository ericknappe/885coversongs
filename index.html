<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Responsive + iOS safe-area -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>WXPN 885 Greatest Cover Songs – Countdown Dashboard</title>

  <style>
    * { box-sizing: border-box; }

    body{
      margin:0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:#111;
      color:#eee;

      height:100vh;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }

    header{
      flex:0 0 auto;
      padding:6px 0 2px;
      text-align:center;
      background:#111;
    }
    header h1{
      margin:0;
      font-size:20px;
      font-weight:600;
      color:#f5f5f5;
    }

    /* Fixed control bar */
    #controls{
      flex:0 0 auto;
      padding:4px 0 8px;
      background:#111;
      display:flex;
      justify-content:center;
      border-bottom:1px solid #222;
    }
    #controls-inner{
      display:flex;
      align-items:center;
      gap:10px;
      max-width:760px;
      width:100%;
      padding:6px 14px;
      border-radius:999px;
      background:#222;
      border:1px solid #333;
    }
    #controls-inner label{
      white-space:nowrap;
      font-size:13px;
      color:#eee;
    }
    #frameLabel{
      min-width:64px;
      text-align:right;
      font-variant-numeric: tabular-nums;
      font-size:13px;
    }

    /* Finger-friendly slider */
    #frameSlider{
      flex:1;
      height:22px;
      -webkit-appearance:none;
      background:transparent;
      touch-action: pan-y;
    }
    #frameSlider::-webkit-slider-runnable-track{
      height:6px;
      background:#444;
      border-radius:999px;
    }
    #frameSlider::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:24px;
      height:24px;
      border-radius:50%;
      background:#eee;
      border:2px solid #111;
      margin-top:-9px;
    }
    #frameSlider::-moz-range-track{
      height:6px;
      background:#444;
      border-radius:999px;
    }
    #frameSlider::-moz-range-thumb{
      width:24px;
      height:24px;
      border-radius:50%;
      background:#eee;
      border:2px solid #111;
    }

    /* Dashboard scroll container */
    #dashboard{
      flex:1 1 auto;
      overflow-y:auto;
      -webkit-overflow-scrolling: touch;

      display:grid;
      grid-auto-rows:42px;
      grid-auto-flow:dense;
      gap:6px;
      padding:6px;
    }

    /* ===== Responsive layout rules ===== */
    /* Desktop/laptop: 3 columns */
    #dashboard{ grid-template-columns: repeat(3, 1fr); }

    /* iPad portrait: 2 columns */
    @media (max-width: 1100px) and (orientation: portrait){
      #dashboard{ grid-template-columns: repeat(2, 1fr); }
    }
    /* iPad landscape: 3 columns */
    @media (max-width: 1400px) and (orientation: landscape){
      #dashboard{ grid-template-columns: repeat(3, 1fr); }
    }
    /* Backup: iPhone portrait forces 1 column */
    @media (max-width: 520px) and (orientation: portrait){
      #dashboard{ grid-template-columns: 1fr !important; }
    }
    /* iPhone landscape: 2 columns */
    @media (max-width: 900px) and (orientation: landscape){
      #dashboard{ grid-template-columns: repeat(2, 1fr) !important; }
    }
    /* Optional JS helper (wins reliably on phones) */
    body.is-phone:not(.is-landscape) #dashboard{ grid-template-columns: 1fr !important; }
    body.is-phone.is-landscape #dashboard{ grid-template-columns: repeat(2, 1fr) !important; }

    .panel{
      background:#181818;
      border:1px solid #333;
      border-radius:6px;
      padding:4px 5px;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      min-height:0;
      cursor: move;
    }
    .panel.is-expanded{ grid-row: span 8; }
    .panel.is-collapsed{ grid-row: span 1; padding-bottom: 0; }
    .panel.is-collapsed .panel-header{ margin-bottom: 0; }

    .panel-header{
      display:flex;
      align-items:center;
      gap:6px;
      margin-bottom:2px;
    }
    .panel-title{
      flex:1;
      font-size:13px;
      font-weight:600;
      color:#f0f0f0;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      text-align:center;
    }
    .panel-toggle{
      font-size:11px;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid #444;
      background:#262626;
      color:#eee;
      cursor:pointer;
    }
    .panel-toggle:hover{ background:#333; }

    .panel-body{
      flex:1;
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    svg.chart{
      width:100%;
      height:100%;
      display:block;
    }

    /* ===== Current item ===== */
    #current-item{
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      text-align:center;
      gap:8px;
      padding-top:4px;
      min-height:0;
    }
    #current-item img{
      max-width:70%;
      height:160px;
      border-radius:8px;
      box-shadow:0 0 8px rgba(0,0,0,0.7);
      object-fit:cover;
      background:#000;
      transition: opacity 0.2s ease-in-out;
    }
    #current-item img.no-art{
      opacity:0;
      box-shadow:none;
    }
    #current-item .item-title{ font-size:15px; font-weight:600; }
    #current-item .item-artist{ font-size:14px; color:#ccc; }
    #current-item .item-meta{ font-size:13px; color:#aaa; }

    .dragging{ opacity:0.6; outline:2px dashed #888; }
    @media (pointer: coarse){ .panel{ cursor: default; } }
    @media (max-width: 800px){
      header h1{ font-size:18px; }
      .panel-title{ font-size:15px; }
      #current-item .item-title{ font-size:17px; }
      #current-item .item-artist{ font-size:15px; }
      #current-item .item-meta{ font-size:14px; }
    }

    /* ===== Player UI ===== */
    .player-actions{ margin-top:8px; display:flex; gap:8px; justify-content:center; }
    .player-actions button{
      font-size:11px;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid #444;
      background:#262626;
      color:#eee;
      cursor:pointer;
    }
    .player-actions button:hover{ background:#333; }

    .player-links{ margin-top:8px; display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
    .player-links a{
      text-decoration:none;
      border:1px solid rgba(255,255,255,.16);
      padding:4px 8px;
      border-radius:999px;
      color:#eee;
      font-size:11px;
    }
    .player-links a:hover{ border-color: rgba(255,255,255,.28); }

    .player-unavailable{
      font-size:11px;
      color:#bdbdbd;
      padding:4px 10px;
      border-radius:999px;
      border:1px dashed rgba(255,255,255,.25);
      background: rgba(255,255,255,.04);
      white-space:nowrap;
    }

    .hidden{ display:none !important; }

    /* ===== Floating player ===== */
    .floating-player{
      position:fixed;
      right:12px;
      bottom:12px;
      width:min(520px, calc(100vw - 24px));
      max-height: calc(100vh - 24px);
      overflow:auto;
      background:#181818;
      border:1px solid #333;
      border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,.45);
      z-index:9999;
    }
    .floating-bar{
      position:sticky;
      top:0;
      background:#181818;
      padding:8px 10px;
      border-bottom:1px solid #2a2a2a;
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap:8px;
    }
    .floating-title{
      font-size:12px;
      font-weight:600;
      color:#eee;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .floating-bar button{
      font-size:11px;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid #444;
      background:#262626;
      color:#eee;
      cursor:pointer;
    }
    .floating-bar button:hover{ background:#333; }
    .floating-embed-wrap{ padding:10px; }
    .floating-embed-wrap iframe{
      width:100%;
      border-radius:10px;
      border:2px solid rgba(255,255,255,0.22);
      background:#0f0f0f;
      display:block;
    }
    @media (max-width: 700px){
      .floating-player{
        left:10px;
        right:10px;
        bottom:10px;
        width:auto;
        max-height:60vh;
      }
    }

    /* ===== Next items ===== */
    .next-items{ width:100%; overflow:auto; max-height:100%; padding: 6px 10px 10px; isolation:isolate; }
    .next-table{ width:100%; table-layout:fixed; border-collapse:separate; border-spacing:0; font-size:12px; position:relative; }
    .next-table thead{
      position: sticky;
      top: 0;
      z-index: 20;
      background: #141414;
      transform: translateZ(0);
      box-shadow: 0 2px 0 rgba(0,0,0,0.35);
    }
    .next-table thead th{
      background: #141414;
      color:#ddd;
      text-align:left;
      padding:6px 6px;
      border-bottom:1px solid rgba(255,255,255,0.12);
      white-space:nowrap;
    }
    .next-table tbody td{
      padding:6px 6px;
      border-bottom:1px solid rgba(255,255,255,0.08);
      vertical-align:top;
    }
    /* Stabilize column widths (fixed layout) without forcing ellipsis.
       Let body cells wrap; keep headers readable. */
    .next-table td, .next-table th{ overflow:hidden; text-overflow:clip; }
    .next-table td:nth-child(1), .next-table th:nth-child(1){ width:56px; white-space:nowrap; }
    .next-table thead th{ white-space:nowrap; }
    .next-table tbody td:nth-child(2),
    .next-table tbody td:nth-child(3),
    .next-table tbody td:nth-child(4){
      white-space:normal;
      overflow-wrap:anywhere;
      word-break:break-word;
      line-height:1.2;
    }
    .next-table tbody tr{ cursor:pointer; }
    .next-table tbody tr:hover{ background: rgba(255,255,255,0.04); }
    .next-table td:nth-child(1){ width:54px; opacity:0.9; }

    #panel-next-items .panel-body{ padding-left:14px; padding-right:14px; }
    #panel-next-items .panel-header{ padding-left:14px; padding-right:14px; }
    #panel-next-items table{ font-size:12px; }
    #panel-next-items th{ font-size:11px; opacity:0.9; }
    #panel-next-items td{ padding-top:6px; padding-bottom:6px; }
  </style>
</head>

<body>
  <header>
    <h1>WXPN 885 Greatest Cover Songs – Countdown Dashboard</h1>
  </header>

  <div id="controls">
    <div id="controls-inner">
      <label for="frameSlider">Song number:</label>
      <input type="range" id="frameSlider" min="0" max="0" value="0" step="1" />
      <div id="frameLabel">0</div>
    </div>
  </div>

  <div id="dashboard">
    <!-- 1) Current item -->
    <div class="panel is-draggable is-expanded" id="panel-current-item">
      <div class="panel-header">
        <span class="panel-title">Current Song</span>
        <button class="panel-toggle" type="button">Hide</button>
      </div>
      <div class="panel-body">
        <div id="current-item">
          <img id="current-album-art" src="" alt="" class="no-art" />
          <div class="item-title" id="current-song-title">Loading…</div>
          <div class="item-artist" id="current-song-artist"></div>
          <div class="item-meta" id="current-song-meta"></div>

          <div class="player-actions">
            <button id="player-play-btn" type="button">Play</button>
            <span id="player-unavailable-msg" class="player-unavailable hidden"></span>
          </div>

          <div id="current-player-links" class="player-links"></div>
        </div>
      </div>
    </div>

    <!-- 2) Next items -->
    <div class="panel is-draggable is-expanded" id="panel-next-items">
      <div class="panel-header">
        <span class="panel-title">Next 10 Songs</span>
        <button class="panel-toggle" type="button">Hide</button>
      </div>
      <div class="panel-body">
        <div class="next-items">
          <table class="next-table">
            <colgroup><col style="width:56px"><col style="width:36%"><col style="width:32%"><col style="width:32%"></colgroup>
            <thead><tr><th>Rank</th><th>Song</th><th>Artist</th><th>Original</th></tr></thead>
            <tbody id="recent-songs-body"></tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- 3..(3+8) Chart slots (max 9 slots) -->
    
    <div class="panel is-draggable is-expanded" id="panel-chart-1" data-panel="chart-slot">
      <div class="panel-header">
        <span class="panel-title">Chart</span>
        <button class="panel-toggle" type="button">Hide</button>
      </div>
      <div class="panel-body"><svg class="chart"></svg></div>
    </div>

    <div class="panel is-draggable is-expanded" id="panel-chart-2" data-panel="chart-slot">
      <div class="panel-header">
        <span class="panel-title">Chart</span>
        <button class="panel-toggle" type="button">Hide</button>
      </div>
      <div class="panel-body"><svg class="chart"></svg></div>
    </div>

    <div class="panel is-draggable is-expanded" id="panel-chart-3" data-panel="chart-slot">
      <div class="panel-header">
        <span class="panel-title">Chart</span>
        <button class="panel-toggle" type="button">Hide</button>
      </div>
      <div class="panel-body"><svg class="chart"></svg></div>
    </div>

    <div class="panel is-draggable is-expanded" id="panel-chart-4" data-panel="chart-slot">
      <div class="panel-header">
        <span class="panel-title">Chart</span>
        <button class="panel-toggle" type="button">Hide</button>
      </div>
      <div class="panel-body"><svg class="chart"></svg></div>
    </div>

    <div class="panel is-draggable is-expanded" id="panel-chart-5" data-panel="chart-slot">
      <div class="panel-header">
        <span class="panel-title">Chart</span>
        <button class="panel-toggle" type="button">Hide</button>
      </div>
      <div class="panel-body"><svg class="chart"></svg></div>
    </div>

    <div class="panel is-draggable is-expanded" id="panel-chart-6" data-panel="chart-slot">
      <div class="panel-header">
        <span class="panel-title">Chart</span>
        <button class="panel-toggle" type="button">Hide</button>
      </div>
      <div class="panel-body"><svg class="chart"></svg></div>
    </div>

    <div class="panel is-draggable is-expanded" id="panel-chart-7" data-panel="chart-slot">
      <div class="panel-header">
        <span class="panel-title">Chart</span>
        <button class="panel-toggle" type="button">Hide</button>
      </div>
      <div class="panel-body"><svg class="chart"></svg></div>
    </div>

    <div class="panel is-draggable is-expanded" id="panel-chart-8" data-panel="chart-slot">
      <div class="panel-header">
        <span class="panel-title">Chart</span>
        <button class="panel-toggle" type="button">Hide</button>
      </div>
      <div class="panel-body"><svg class="chart"></svg></div>
    </div>

    <div class="panel is-draggable is-expanded" id="panel-chart-9" data-panel="chart-slot">
      <div class="panel-header">
        <span class="panel-title">Chart</span>
        <button class="panel-toggle" type="button">Hide</button>
      </div>
      <div class="panel-body"><svg class="chart"></svg></div>
    </div>
  </div>

  <!-- Floating detachable player -->
  <div id="floating-player" class="floating-player hidden" aria-live="polite">
    <div class="floating-bar">
      <div class="floating-title" id="floating-title">Now Playing</div>
      <button id="player-close-btn" type="button">Close</button>
    </div>
    <div class="floating-embed-wrap">
      <div id="floating-player-embed"></div>
      <div id="floating-player-links" class="player-links"></div>
    </div>
  </div>

<script>
/* ==========================================================
   Config
   - Local runs must use a small server (CORS/file://):
     python3 -m http.server
   ========================================================== */
const urlParams = new URLSearchParams(window.location.search);
const DATA_ENDPOINT = urlParams.get("data_endpoint") || "data/2025_885_annotated.json";

/* Defaults (cover-mode set; future variants can swap metric sets) */
const MIN_DISPLAY_COUNT = 2;          // minimum to display on a chart at a given frame
const MOMENTUM_WINDOW = 20;
const FAST_RISER_THRESHOLD = 5;

const TOP_N_DEFAULT = 15;
const TOP_N_GENRES = 20;
const TOP_N_DECADES = 10;
const TOP_N_YEARS = 15;
const TOP_N_ORIG_SONGS = 15;

const MAX_LABEL_CHARS = 25;
const BAR_HEIGHT_FACTOR = 1/3;

/* Elements */
const frameSlider = document.getElementById("frameSlider");
const frameLabel  = document.getElementById("frameLabel");

const currentAlbumArt  = document.getElementById("current-album-art");
const currentSongTitle = document.getElementById("current-song-title");
const currentSongArtist= document.getElementById("current-song-artist");
const currentSongMeta  = document.getElementById("current-song-meta");
const recentSongsBody  = document.getElementById("recent-songs-body");

/* State */
let initialized = false;
let sortedSongs = [];
let frameRanks  = [];
let metrics     = [];
let metricState = {};
let currentFrameIndex = 0;
let rankToRow = {};
let rankToFrameIndex = {};

/* ==========================================================
   Helpers (trim + CR/LF hygiene)
   ========================================================== */
function cleanText(v){
  // Normalize strings coming from JSON / PHP exports:
  // - trim whitespace
  // - normalize CR/LF
  // - unescape common PHP-style escapes (\')
  return String(v == null ? "" : v)
    .replace(/\\r\\n/g, "\n")
    .replace(/\\r/g, "\n")
    .replace(/\\'/g, "'")
    .trim();
}
function escapeHtml(s){
  return String(s || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}
function truncateLabel(label, maxLen){
  const s = cleanText(label);
  if (s.length <= maxLen) return s;
  if (maxLen <= 1) return s.slice(0, maxLen);
  return s.slice(0, maxLen - 1) + "…";
}
function parseYearFromString(value){
  if (value === null || value === undefined) return null;
  // Accept numbers directly
  if (typeof value === "number" && isFinite(value)){
    const y = Math.trunc(value);
    if (y >= 1800 && y <= 2100) return y;
    return null;
  }
  let s = cleanText(String(value));
  if (!s) return null;
  // Normalize any escaped quotes
  s = s.replace(/\\"/g, '"');
  // Prefer a clean 4-digit year; don't rely solely on word boundaries.
  const m = s.match(/(18\d{2}|19\d{2}|20\d{2})/);
  if (!m) return null;
  const year = parseInt(m[0], 10);
  if (isNaN(year) || year < 1800 || year > 2100) return null;
  return year;
}
function computeDecade(year){
  if (year === null || year === undefined || isNaN(year)) return null;
  const y = parseInt(year, 10);
  return (Math.floor(y / 10) * 10) + "s";
}

/* PHP-serialized genre extraction: grabs quoted strings */
function parsePhpGenre(value){
  // Supports PHP-serialized arrays like:
  // a:4:{i:0;s:16:"psychedelic rock";...}
  // Some JSON exports may double-escape quotes, yielding \" in the decoded string.
  // Normalize those so extraction works reliably.
  let s = cleanText(value);
  if (!s) return [];
  if (!s.startsWith("a:")) return [];
  s = s.replace(/\"/g, '"');
  const regex = /s:\d+:"(.*?)"/g;
  const out = [];
  let m;
  while ((m = regex.exec(s)) !== null) out.push(m[1]);
  return out.map(cleanText).filter(Boolean);
}
function parseGenreList(value){
  const s = cleanText(value);
  if (!s) return [];
  const looksSerialized = s.startsWith("a:");
  const php = parsePhpGenre(s);
  if (looksSerialized){
    // If it looks serialized but yields no strings (e.g., a:0:{}), treat as no genres.
    return php.length ? php : [];
  }
  if (php.length) return php;
  return [s];
}

/* ==========================================================
   Next 10 Songs panel
   ========================================================== */
function renderUpcomingFromCurrent(currentRank){
  if (!recentSongsBody) return;

  const cr = Number(currentRank || 0);
  if (!cr || isNaN(cr) || cr >= 885){
    recentSongsBody.innerHTML = "";
    return;
  }

  const start = cr;
  const end = Math.min(885, cr + 9);

  const rows = [];
  for (let r = start; r <= end; r++){
    const row = rankToRow[r];
    if (row) rows.push(row);
  }

  let html = "";
  for (let i=0; i<rows.length; i++){
    const rr = rows[i];
    const rank = rr.rank != null ? String(rr.rank) : "";
    const song = escapeHtml(cleanText(rr.song));
    const artist = escapeHtml(cleanText(rr.artist));
    const orig = escapeHtml(cleanText(rr.originalArtist));
    html += `<tr data-rank="${escapeHtml(rank)}"><td>${escapeHtml(rank)}</td><td>${song}</td><td>${artist}</td><td>${orig}</td></tr>`;
  }
  recentSongsBody.innerHTML = html;
}

/* ==========================================================
   Charts (SVG horizontal bar charts, no external libs)
   ========================================================== */
const COLOR_PALETTE = [
  "#4e79a7","#f28e2b","#e15759","#76b7b2","#59a14f",
  "#edc948","#b07aa1","#ff9da7","#9c755f","#bab0ab",
  "#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3",
  "#fdb462","#b3de69","#fccde5","#d9d9d9","#bc80bd",
  "#ccebc5","#ffed6f"
];
function hashString(str){
  const s = String(str || "");
  let h = 2166136261;
  for (let i=0; i<s.length; i++){
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return (h >>> 0);
}
function colorForCategory(cat){
  const idx = hashString(cat) % COLOR_PALETTE.length;
  return COLOR_PALETTE[idx];
}
function chooseTickStep(maxVal){
  if (maxVal <= 20) return 2;
  if (maxVal <= 50) return 5;
  if (maxVal <= 250) return 25;
  if (maxVal <= 500) return 50;
  return 100;
}
function clearSvg(svg){
  while (svg.firstChild) svg.removeChild(svg.firstChild);
}
function svgEl(tag, attrs){
  const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
  if (attrs){
    Object.keys(attrs).forEach(k => el.setAttribute(k, String(attrs[k])));
  }
  return el;
}
function setupChart(svgElement, topN, globalMax, allowedSet){
  const svg = svgElement;
  clearSvg(svg);

  const width = svg.clientWidth || 400;
  const height = svg.clientHeight || 240;

  let marginLeft;
  if (width <= 360) marginLeft = 90;
  else if (width <= 420) marginLeft = 105;
  else if (width <= 500) marginLeft = 115;
  else if (width <= 900) marginLeft = 150;
  else marginLeft = 165;

  const margin = { top: 4, right: 8, bottom: 18, left: marginLeft };
  const innerWidth = Math.max(10, width - margin.left - margin.right);
  const innerHeight = Math.max(10, height - margin.top - margin.bottom);

  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

  const g = svgEl("g", { transform: `translate(${margin.left},${margin.top})` });
  svg.appendChild(g);

  const maxVal = Math.max(globalMax || 2, 2);
  const step = chooseTickStep(maxVal);
  const xMaxRounded = Math.ceil(maxVal / step) * step;

  function xScale(v){
    const vv = Math.max(0, Math.min(xMaxRounded, Number(v) || 0));
    return (vv / xMaxRounded) * innerWidth;
  }

  // Grid + integer ticks
  for (let t=0; t<=xMaxRounded; t += step){
    const x = xScale(t);
    g.appendChild(svgEl("line", { x1:x, y1:0, x2:x, y2:innerHeight, stroke:"#333", "stroke-dasharray":"2,2" }));
    const tick = svgEl("text", { x:x, y:innerHeight+14, fill:"#ccc", "font-size":"9", "text-anchor":"middle" });
    tick.textContent = String(t);
    g.appendChild(tick);
  }

  const slotHeight = innerHeight / topN;
  const barHeight = slotHeight * BAR_HEIGHT_FACTOR;

  return { svg, g, xScale, slotHeight, barHeight, topN, allowed: allowedSet };
}

function updateChart(chart, frameCounts, prevFrameCounts, options){
  const g = chart.g;
  const oldLayer = chart._layer;
  if (oldLayer && oldLayer.parentNode) oldLayer.parentNode.removeChild(oldLayer);
  const layer = svgEl("g");
  chart._layer = layer;
  g.appendChild(layer);

  const minDisplay = options.minDisplayCount;
  const fastThreshold = options.fastRiserThreshold;

  const entries = [];
  const fc = frameCounts || {};
  for (const k in fc){
    const cat = k;
    const cnt = fc[k];
    if (!chart.allowed.has(cat)) continue;
    if (cnt == null || cnt < minDisplay) continue;
    entries.push([cat, cnt]);
  }
  entries.sort((a,b) => (b[1]-a[1]) || String(a[0]).localeCompare(String(b[0])));
  const ordered = entries.slice(0, chart.topN);
  const count = ordered.length;
  if (!count) return;

  const startSlot = chart.topN - count;
  const slotPositions = [];
  for (let i=0; i<count; i++){
    const slotIndex = startSlot + i;
    slotPositions.push(slotIndex * chart.slotHeight + (chart.slotHeight - chart.barHeight)/2);
  }

  const fastSet = new Set();
  const pc = prevFrameCounts || {};
  for (let i=0; i<ordered.length; i++){
    const cat = ordered[i][0];
    const val = ordered[i][1];
    const prevVal = pc[cat] || 0;
    if ((val - prevVal) >= fastThreshold) fastSet.add(cat);
  }

  for (let i=0; i<ordered.length; i++){
    const cat = ordered[i][0];
    const val = ordered[i][1];
    const y = slotPositions[i];
    const w = chart.xScale(val);

    layer.appendChild(svgEl("rect", { x:0, y:y, width:w, height:chart.barHeight, fill: colorForCategory(cat) }));

    const label = svgEl("text", {
      x:-6, y:y + chart.barHeight/2, dy:"0.35em",
      fill:"#eee", "font-size":"10", "text-anchor":"end"
    });
    const base = cleanText(cat);
    label.textContent = (fastSet.has(cat) ? "↑ " : "") + truncateLabel(base, MAX_LABEL_CHARS);
    if (fastSet.has(cat)) label.setAttribute("font-weight", "bold");
    const title = svgEl("title");
    title.textContent = base;
    label.appendChild(title);
    layer.appendChild(label);
  }
}

function computeGlobalMax(framesCounts, minDisplay){
  let maxVal = 0;
  for (let i=0; i<framesCounts.length; i++){
    const frame = framesCounts[i];
    if (!frame) continue;
    for (const k in frame){
      const v = frame[k];
      if (v != null && v >= minDisplay && v > maxVal) maxVal = v;
    }
  }
  return maxVal;
}

function buildMetricTimeSeries(sortedRows, categoryFn, minCountFinal){
  // Canonicalize category keys as strings everywhere.
  // Prevents Set membership mismatches between numeric keys (e.g., 1968)
  // and Object snapshot keys (always strings).
  const finalCounts = new Map();
  for (let i=0; i<sortedRows.length; i++){
    const row = sortedRows[i];
    const cats = categoryFn(row) || [];
    for (let j=0; j<cats.length; j++){
      const raw = cats[j];
      const key = cleanText(String(raw));
      if (!key) continue;
      finalCounts.set(key, (finalCounts.get(key) || 0) + 1);
    }
  }

  const allowed = new Set();
  finalCounts.forEach((cnt, key) => { if (cnt >= minCountFinal) allowed.add(String(key)); });

  const frames = [];
  const currentCounts = new Map();
  for (let i=0; i<sortedRows.length; i++){
    const row = sortedRows[i];
    const cats = categoryFn(row) || [];
    for (let j=0; j<cats.length; j++){
      const raw = cats[j];
      const key = cleanText(String(raw));
      if (!key) continue;
      if (!allowed.has(key)) continue;
      currentCounts.set(key, (currentCounts.get(key) || 0) + 1);
    }
    const snapshot = {};
    currentCounts.forEach((v,k) => { snapshot[String(k)] = v; });
    frames.push(snapshot);
  }

  return { frames, allowed };
}

/* ==========================================================
   Player (on-demand, floating)
   - Only create/reload iframe when Play is pressed
   - While open, slider changes do NOT change the embed
   ========================================================== */
(function(){
  if (window.Race2Player) return;

  const state = {
    open: false,
    lastSelected: null,   // current slider-selected row
    playingRow: null      // row loaded into iframe
  };

  function pickProvider(media){
    if (!media) return null;

    const bc = media.bandcamp;
    if (bc && (bc.status === "manual" || bc.status === "found") && bc.embed_src){
      return { key:"bandcamp", embed_src: cleanText(bc.embed_src), height:120 };
    }
    const sp = media.spotify;
    if (sp && sp.status === "found" && sp.embed_src){
      return { key:"spotify", embed_src: cleanText(sp.embed_src), height:152 };
    }
    const dz = media.deezer;
    if (dz && dz.status === "found" && dz.embed_src){
      return { key:"deezer", embed_src: cleanText(dz.embed_src), height:200 };
    }
    return null;
  }

  function setFloatingTitle(row){
    const el = document.getElementById("floating-title");
    if (!el) return;
    const t = cleanText((row && row.song) || "");
    const a = cleanText((row && row.artist) || "");
    el.textContent = (t && a) ? (t + " — " + a) : "Now Playing";
  }

  function setAttachedAvailability(row){
    const playBtn = document.getElementById("player-play-btn");
    const msg = document.getElementById("player-unavailable-msg");
    if (!playBtn || !msg) return;

    const provider = pickProvider(row && row.media);
    if (provider && provider.embed_src){
      playBtn.classList.remove("hidden");
      playBtn.disabled = false;

      // If the selected row is the one currently playing, reflect it; otherwise keep "Play".
      const isPlayingSelected = state.open && state.playingRow && (state.playingRow === row);
      playBtn.textContent = isPlayingSelected ? "Playing" : "Play";

      msg.classList.add("hidden");
      msg.textContent = "";
    } else {
      playBtn.classList.add("hidden");
      msg.classList.remove("hidden");
      msg.textContent = "No preview available";
    }
  }

  function renderFloatingLinks(row){
    const linksEl = document.getElementById("floating-player-links");
    if (!linksEl) return;

    const m = (row && row.media) ? row.media : {};
    const links = [];
    if (m.spotify && m.spotify.url)  links.push('<a href="' + escapeHtml(cleanText(m.spotify.url)) + '">Open in Spotify</a>');
    if (m.deezer  && m.deezer.url)   links.push('<a href="' + escapeHtml(cleanText(m.deezer.url)) + '">Open in Deezer</a>');
    if (m.bandcamp && m.bandcamp.url) links.push('<a href="' + escapeHtml(cleanText(m.bandcamp.url)) + '">Support on Bandcamp</a>');
    linksEl.innerHTML = links.join("");
  }

  function createIframeForRow(row){
    const embedEl = document.getElementById("floating-player-embed");
    if (!embedEl) return;

    const provider = pickProvider(row && row.media);
    if (provider && provider.embed_src){
      embedEl.innerHTML =
        '<iframe loading="lazy"' +
        ' src="' + escapeHtml(provider.embed_src) + '"' +
        ' style="height:' + String(provider.height) + 'px;"' +
        ' allow="autoplay; encrypted-media; fullscreen; picture-in-picture"' +
        ' referrerpolicy="no-referrer"></iframe>';
    } else {
      embedEl.innerHTML = '<div class="item-meta" style="margin-top:10px;color:#aaa;">No embedded player available.</div>';
    }
  }

  function openFloating(){
    const floating = document.getElementById("floating-player");
    if (!floating) return;
    state.open = true;
    floating.classList.remove("hidden");
  }

  function close(){
    const floating = document.getElementById("floating-player");
    if (!floating) return;
    state.open = false;
    floating.classList.add("hidden");
    const embedEl = document.getElementById("floating-player-embed");
    if (embedEl) embedEl.innerHTML = "";
    state.playingRow = null;

    const playBtn = document.getElementById("player-play-btn");
    if (playBtn) playBtn.textContent = "Play";
  }

  function play(){
    const row = state.lastSelected;
    const provider = pickProvider(row && row.media);
    if (!provider || !provider.embed_src) return;

    // Lock in the row being played until the user presses Play again.
    state.playingRow = row;

    openFloating();
    setFloatingTitle(state.playingRow);
    createIframeForRow(state.playingRow);
    renderFloatingLinks(state.playingRow);

    const playBtn = document.getElementById("player-play-btn");
    if (playBtn) playBtn.textContent = "Playing";
  }

  function update(row){
    state.lastSelected = row;
    setAttachedAvailability(row);

    if (state.open){
      // Update title to reflect the playing row (not the selected row).
      setFloatingTitle(state.playingRow || row);
      // IMPORTANT: do NOT recreate/reload iframe here.
    }
  }

  window.Race2Player = { update, play, close };
})();

/* Wire player buttons */
document.addEventListener("click", function(e){
  if (!e || !e.target) return;
  if (e.target.id === "player-play-btn"){
    window.Race2Player && window.Race2Player.play && window.Race2Player.play();
  }
  if (e.target.id === "player-close-btn"){
    window.Race2Player && window.Race2Player.close && window.Race2Player.close();
  }
});

/* ==========================================================
   Panel collapse, DnD, responsive device classes
   ========================================================== */
function setCollapsed(panel, collapsed){
  const btn = panel.querySelector(".panel-toggle");
  const body = panel.querySelector(".panel-body");
  if (!btn || !body) return;

  if (collapsed){
    body.style.display = "none";
    panel.classList.add("is-collapsed");
    panel.classList.remove("is-expanded");
    btn.textContent = "Show";
  } else {
    body.style.display = "";
    panel.classList.remove("is-collapsed");
    panel.classList.add("is-expanded");
    btn.textContent = "Hide";
  }
}
function initPanelToggles(){
  document.querySelectorAll(".panel").forEach(panel => {
    const btn = panel.querySelector(".panel-toggle");
    const body = panel.querySelector(".panel-body");
    if (!btn || !body) return;

    panel.classList.add("is-expanded");
    panel.classList.remove("is-collapsed");

    btn.addEventListener("click", () => {
      const currentlyHidden = (body.style.display === "none");
      setCollapsed(panel, !currentlyHidden);
      if (initialized) rebuildChartsAndRedraw();
    });
  });
}
function initDragAndDrop(){
  const dashboard = document.getElementById("dashboard");
  const finePointer = window.matchMedia && window.matchMedia("(pointer: fine)").matches;
  if (!finePointer) return;

  let dragSrcEl = null;
  dashboard.querySelectorAll(".panel.is-draggable").forEach(panel => {
    panel.setAttribute("draggable", "true");

    panel.addEventListener("dragstart", e => {
      dragSrcEl = panel;
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setData("text/plain", "");
      panel.classList.add("dragging");
    });

    panel.addEventListener("dragend", () => panel.classList.remove("dragging"));

    panel.addEventListener("dragover", e => {
      e.preventDefault();
      if (!dragSrcEl || dragSrcEl === panel) return;

      const rect = panel.getBoundingClientRect();
      const offset = e.clientY - rect.top;
      const midpoint = rect.height / 2;
      if (offset > midpoint) dashboard.insertBefore(dragSrcEl, panel.nextSibling);
      else dashboard.insertBefore(dragSrcEl, panel);
    });
  });
}

function stepSlider(delta){
  const min = Number(frameSlider.min);
  const max = Number(frameSlider.max);
  const cur = Number(frameSlider.value) || 0;
  const next = Math.max(min, Math.min(max, cur + delta));
  if (next !== cur){
    frameSlider.value = String(next);
    frameSlider.dispatchEvent(new Event("input"));
  }
}
function initKeyboardStepping(){
  window.addEventListener("keydown", (e) => {
    const tag = (document.activeElement && document.activeElement.tagName) || "";
    if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT") return;

    if (e.key === "ArrowLeft") stepSlider(-1);
    if (e.key === "ArrowRight") stepSlider(1);
    if (e.key === "PageUp") stepSlider(-10);
    if (e.key === "PageDown") stepSlider(10);
  });
}
function initSwipeStepping(){
  let touchStartX = null;
  document.addEventListener("touchstart", (e) => {
    if (!e.touches || !e.touches.length) return;
    touchStartX = e.touches[0].clientX;
  }, { passive:true });

  document.addEventListener("touchend", (e) => {
    if (touchStartX === null) return;
    const endX = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : null;
    if (endX === null) return;

    const dx = endX - touchStartX;
    touchStartX = null;

    if (Math.abs(dx) < 40) return;
    if (dx > 0) stepSlider(-1);
    else stepSlider(1);
  }, { passive:true });
}
function initResizeHandler(){
  let t = null;
  window.addEventListener("resize", () => {
    if (!initialized) return;
    clearTimeout(t);
    t = setTimeout(() => rebuildChartsAndRedraw(), 80);
  });
}

function applyResponsiveDeviceClass(){
  const w = window.innerWidth || 9999;
  const h = window.innerHeight || 9999;
  const minSide = Math.min(w, h);
  document.body.classList.toggle("is-phone", (minSide <= 520));
  document.body.classList.toggle("is-landscape", (w > h));
}

function applyMobileDefaults(){
  const w = window.innerWidth || 9999;
  if (w > 650) return;

  const show = { "panel-current-item": true, "panel-next-items": true };
  document.querySelectorAll(".panel").forEach(panel => {
    if (!panel.id) return;
    setCollapsed(panel, !show[panel.id]);
  });
}

/* ==========================================================
   Metric slot wiring (max 9 slots)
   ========================================================== */
function getChartSlots(){
  return Array.from(document.querySelectorAll('[data-panel="chart-slot"]'));
}

function bindMetricsToSlots(metricList){
  const slots = getChartSlots();
  // First hide all slots
  for (let i=0; i<slots.length; i++){
    const slot = slots[i];
    slot.classList.add("hidden");
    slot.dataset.metric = "";
    const titleEl = slot.querySelector(".panel-title");
    const svg = slot.querySelector("svg.chart");
    if (titleEl) titleEl.textContent = "Chart";
    if (svg) { clearSvg(svg); }
  }

  // Then assign metrics to available slots
  for (let i=0; i<metricList.length && i<slots.length; i++){
    const slot = slots[i];
    const metric = metricList[i];
    slot.classList.remove("hidden");
    slot.dataset.metric = metric.key;

    const titleEl = slot.querySelector(".panel-title");
    if (titleEl) titleEl.textContent = metric.title;

    // Ensure SVG has a stable ID for this metric key
    const svg = slot.querySelector("svg.chart");
    if (svg) svg.id = "chart-" + metric.key;
  }
}

/* ==========================================================
   Main
   ========================================================== */
async function init(){
  initPanelToggles();
  initDragAndDrop();
  initKeyboardStepping();
  initSwipeStepping();
  initResizeHandler();

  applyResponsiveDeviceClass();
  applyMobileDefaults();

  try{
    const resp = await fetch(DATA_ENDPOINT);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    if (!Array.isArray(data)) throw new Error("Data endpoint must return an array");

    const raw = data.map(d => ({ ...d }));

    raw.forEach(row => {
      row.id = row.id != null ? cleanText(row.id) : row.id;
      row.artist = cleanText(row.artist);
      row.song = cleanText(row.song);
      row.album = cleanText(row.album);
      row.releaseDate = cleanText(row.releaseDate);
      row.albumArt = cleanText(row.albumArt);
      row.originalArtist = cleanText(row.originalArtist);
      row.originalYear = cleanText(row.originalYear);
      row.genre = (row.genre == null ? null : String(row.genre));

      row.rank = row.rank != null ? Number(row.rank) : null;

      row.genre_list = parseGenreList(row.genre);
      row.originalYear_parsed = parseYearFromString(row.originalYear);
      row.coverYear_parsed = parseYearFromString(row.releaseDate);
      row.originalDecade = computeDecade(row.originalYear_parsed);

      const song = row.song || null;
      const oa = row.originalArtist || null;
      row.originalSongCombo = (song && oa) ? `${song} — ${oa}` : null;

    // One-time sanity checks (safe to keep; helps diagnose empty charts)
    try{
      let cCover=0, cOrig=0, cOrigDec=0;
      for (let i=0; i<raw.length; i++){
        if (raw[i].coverYear_parsed != null) cCover++;
        if (raw[i].originalYear_parsed != null) cOrig++;
        if (raw[i].originalDecade != null) cOrigDec++;
      }
      console.info("[Race2] Parsed coverYear:", cCover, "origYear:", cOrig, "origDecade:", cOrigDec, "of", raw.length);
      if (cCover === 0 || cOrig === 0){
        const sample = raw.slice(0, 8).map(r => ({rank:r.rank, releaseDate:r.releaseDate, originalYear:r.originalYear}));
        console.info("[Race2] Year samples:", sample);
      }
    } catch(e) { /* ignore */ }

    });

    const filtered = raw.filter(row => row.rank != null && !isNaN(row.rank));
    if (!filtered.length){
      frameLabel.textContent = "0";
      return;
    }

    // Rank descending: 885 -> 1
    sortedSongs = filtered.slice().sort((a,b) => (b.rank - a.rank));
    frameRanks = sortedSongs.map(r => r.rank);

    rankToRow = {};
    rankToFrameIndex = {};
    for (let i=0; i<sortedSongs.length; i++){
      const r = sortedSongs[i];
      const rk = Number(r.rank);
      rankToRow[rk] = r;
      rankToFrameIndex[rk] = i;
    }

    // Cover-mode metric set (bind to slots)
    const coverMetrics = [
      { key:"orig_artists", title:"Most Covered Original Artists", topN: TOP_N_DEFAULT, minFinal: 2, categoryFn: row => row.originalArtist ? [String(row.originalArtist)] : [] },
      { key:"cover_artists", title:"Most Frequent Cover Artists", topN: TOP_N_DEFAULT, minFinal: 2, categoryFn: row => row.artist ? [String(row.artist)] : [] },
      { key:"orig_years", title:"Most Covered Original Years", topN: TOP_N_YEARS, minFinal: 2, categoryFn: row => row.originalYear_parsed ? [String(row.originalYear_parsed)] : [] },
      { key:"orig_decades", title:"Most Covered Original Decades", topN: TOP_N_DECADES, minFinal: 2, categoryFn: row => row.originalDecade ? [String(row.originalDecade)] : [] },
      { key:"cover_years", title:"Most Frequent Cover Years", topN: TOP_N_YEARS, minFinal: 2, categoryFn: row => row.coverYear_parsed ? [String(row.coverYear_parsed)] : [] },
      { key:"orig_songs", title:"Most Covered Original Songs", topN: TOP_N_ORIG_SONGS, minFinal: 2, categoryFn: row => row.originalSongCombo ? [String(row.originalSongCombo)] : [] },
      { key:"genres", title:"Most Represented Genres", topN: TOP_N_GENRES, minFinal: 3, categoryFn: row => row.genre_list || [] }
    ];

    bindMetricsToSlots(coverMetrics);

    metrics = coverMetrics;

    metricState = {};
    for (let i=0; i<metrics.length; i++){
      const metric = metrics[i];
      const built = buildMetricTimeSeries(sortedSongs, metric.categoryFn, metric.minFinal);
      const globalMax = computeGlobalMax(built.frames, MIN_DISPLAY_COUNT);

      const svgEl = document.getElementById("chart-" + metric.key);
      const chart = svgEl ? setupChart(svgEl, metric.topN, globalMax, built.allowed) : null;

      metricState[metric.key] = { frames: built.frames, allowed: built.allowed, globalMax, chart };
    }

    const numFrames = sortedSongs.length;
    frameSlider.min = 0;
    frameSlider.max = numFrames - 1;
    frameSlider.value = 0;
    currentFrameIndex = 0;

    frameSlider.addEventListener("input", e => {
      const idx = Number(e.target.value) || 0;
      updateDashboard(idx);
    });

    // Clickable next-items rows
    if (recentSongsBody){
      recentSongsBody.addEventListener("click", function(ev){
        const tr = ev.target && ev.target.closest ? ev.target.closest("tr") : null;
        if (!tr) return;
        const r = Number(tr.getAttribute("data-rank") || 0);
        if (!r || isNaN(r)) return;
        const idx2 = (r in rankToFrameIndex) ? rankToFrameIndex[r] : null;
        if (idx2 == null) return;
        frameSlider.value = String(idx2);
        updateDashboard(idx2);
      });
    }

    initialized = true;
    updateDashboard(currentFrameIndex);

  } catch(err){
    console.error(err);
    frameLabel.textContent = "0";
    currentSongTitle.textContent = "Failed to load data";
  }
}

function rebuildChartsAndRedraw(){
  for (let i=0; i<metrics.length; i++){
    const metric = metrics[i];
    const state = metricState[metric.key];
    const svgEl = document.getElementById("chart-" + metric.key);
    if (!state || !svgEl) continue;
    state.chart = setupChart(svgEl, metric.topN, state.globalMax, state.allowed);
  }
  updateDashboard(currentFrameIndex);
}

function updateDashboard(frameIndex){
  if (!sortedSongs.length) return;

  const numFrames = sortedSongs.length;
  currentFrameIndex = Math.max(0, Math.min(numFrames - 1, frameIndex));

  const rank = frameRanks[currentFrameIndex];
  frameLabel.textContent = rank != null ? String(rank) : "";

  // Charts
  for (let i=0; i<metrics.length; i++){
    const metric = metrics[i];
    const state = metricState[metric.key];
    if (!state || !state.chart) continue;

    const frameCounts = state.frames[currentFrameIndex] || {};
    const prevIndex = Math.max(0, currentFrameIndex - MOMENTUM_WINDOW);
    const prevCounts = state.frames[prevIndex] || {};

    updateChart(state.chart, frameCounts, prevCounts, { minDisplayCount: MIN_DISPLAY_COUNT, fastRiserThreshold: FAST_RISER_THRESHOLD });
  }

  // Current item panel
  const row = sortedSongs[currentFrameIndex];
  const imgUrl = cleanText(row.albumArt || "");
  if (imgUrl){
    currentAlbumArt.classList.remove("no-art");
    currentAlbumArt.src = imgUrl;
    currentAlbumArt.alt = `${cleanText(row.song || "")} – ${cleanText(row.artist || "")}`;
  } else {
    currentAlbumArt.classList.add("no-art");
    currentAlbumArt.removeAttribute("src");
    currentAlbumArt.alt = "";
  }

  const title = cleanText(row.song || "(Unknown song)");
  const artist = cleanText(row.artist || "(Unknown cover artist)");
  const origArtist = cleanText(row.originalArtist || "(Unknown original artist)");
  const origYear = row.originalYear_parsed ? String(row.originalYear_parsed) : "Unknown";
  const coverYear = row.coverYear_parsed ? String(row.coverYear_parsed) : "Unknown";

  currentSongTitle.textContent = title;
  currentSongArtist.textContent = `${artist} (covering ${origArtist})`;
  currentSongMeta.textContent = `Rank ${row.rank} · Original year: ${origYear} · Cover year: ${coverYear}`;

  // Next 10
  renderUpcomingFromCurrent(row.rank);

  // Current links (same-tab)
  const linksEl = document.getElementById("current-player-links");
  if (linksEl){
    const m = row.media || {};
    const links = [];
    if (m.spotify && m.spotify.url)  links.push('<a href="' + escapeHtml(cleanText(m.spotify.url)) + '">Spotify</a>');
    if (m.deezer  && m.deezer.url)   links.push('<a href="' + escapeHtml(cleanText(m.deezer.url)) + '">Deezer</a>');
    if (m.bandcamp && m.bandcamp.url) links.push('<a href="' + escapeHtml(cleanText(m.bandcamp.url)) + '">Bandcamp</a>');
    linksEl.innerHTML = links.join("");
  }

  // Player UI update only (no iframe reload)
  window.Race2Player && window.Race2Player.update && window.Race2Player.update(row);
}

/* Boot */
window.addEventListener("load", init);
window.addEventListener("load", applyResponsiveDeviceClass);
window.addEventListener("resize", applyResponsiveDeviceClass);
</script>
</body>
</html>
