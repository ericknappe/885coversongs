<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>WXPN 885 Greatest Cover Songs – Countdown Dashboard</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;

      height: 100vh;
      overflow: hidden; /* Option 1: page doesn't scroll */
      display: flex;
      flex-direction: column;
    }

    header {
      flex: 0 0 auto;
      padding: 6px 0 2px;
      text-align: center;
      background: #111;
    }
    header h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
      color: #f5f5f5;
    }

    #controls {
      flex: 0 0 auto;
      padding: 4px 0 8px;
      background: #111;
      display: flex;
      justify-content: center;
      border-bottom: 1px solid #222;
    }
    #controls-inner {
      display: flex;
      align-items: center;
      gap: 10px;
      max-width: 720px;
      width: 100%;
      padding: 6px 14px;
      border-radius: 999px;
      background: #222;
      border: 1px solid #333;
    }
    #controls-inner label {
      white-space: nowrap;
      font-size: 13px;
      color: #eee;
    }
    #frameLabel {
      min-width: 64px;
      text-align: right;
      font-variant-numeric: tabular-nums;
      font-size: 13px;
    }

    /* Finger-friendly slider */
    #frameSlider {
      flex: 1;
      height: 22px;
      -webkit-appearance: none;
      background: transparent;
      touch-action: pan-y;
    }
    #frameSlider::-webkit-slider-runnable-track {
      height: 6px;
      background: #444;
      border-radius: 999px;
    }
    #frameSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #eee;
      border: 2px solid #111;
      margin-top: -9px;
    }
    #frameSlider::-moz-range-track {
      height: 6px;
      background: #444;
      border-radius: 999px;
    }
    #frameSlider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #eee;
      border: 2px solid #111;
    }

    /* Dashboard is the scroll container */
    #dashboard {
      flex: 1 1 auto;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;

      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-auto-rows: 42px;      /* base row unit */
      grid-auto-flow: dense;     /* pack collapsed tiles upward */
      gap: 6px;
      padding: 6px;
    }

    @media (max-width: 1200px) { #dashboard { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 800px)  { #dashboard { grid-template-columns: repeat(2, 1fr); } }

    .cell {
      background: #181818;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 4px 5px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0;
      cursor: move;
    }
    .cell.is-expanded { grid-row: span 8; }
    .cell.is-collapsed { grid-row: span 1; padding-bottom: 0; }
    .cell.is-collapsed .cell-header { margin-bottom: 0; }

    .cell-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 2px;
    }
    .cell-title {
      flex: 1;
      font-size: 13px;
      font-weight: 600;
      color: #f0f0f0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: center;
    }
    .cell-toggle {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #444;
      background: #262626;
      color: #eee;
      cursor: pointer;
    }
    .cell-toggle:hover { background: #333; }

    .cell-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    svg.chart {
      width: 100%;
      height: 100%;
      display: block;
    }

    #current-song {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      text-align: center;
      gap: 8px;
      padding-top: 4px;
      min-height: 0;
    }

    /* fixed art box to prevent jumpiness */
    #current-song img {
      max-width: 70%;
      height: 160px;
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0,0,0,0.7);
      object-fit: cover;
      background: #000;
      transition: opacity 0.2s ease-in-out;
    }
    #current-song img.no-art {
      opacity: 0;
      box-shadow: none;
    }

    #current-song .song-title { font-size: 15px; font-weight: 600; }
    #current-song .song-artist { font-size: 14px; color: #ccc; }
    #current-song .song-meta { font-size: 13px; color: #aaa; }

    .dragging { opacity: 0.6; outline: 2px dashed #888; }

    @media (pointer: coarse) { .cell { cursor: default; } }
    @media (max-width: 800px) {
      header h1 { font-size: 18px; }
      .cell-title { font-size: 15px; }
      #current-song .song-title { font-size: 17px; }
      #current-song .song-artist { font-size: 15px; }
      #current-song .song-meta { font-size: 14px; }
    }

    /* ===== Current Song Player UI ===== */
    .player-actions { margin-top: 8px; display:flex; gap:8px; justify-content:center; }
    .player-actions button {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #444;
      background: #262626;
      color: #eee;
      cursor: pointer;
    }
    .player-actions button:hover { background:#333; }

    .player-links { margin-top: 8px; display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
    .player-links a {
      text-decoration:none;
      border:1px solid rgba(255,255,255,.16);
      padding:4px 8px;
      border-radius:999px;
      color:#eee;
      font-size: 11px;
    }
    .player-links a:hover { border-color: rgba(255,255,255,.28); }

    .player-unavailable{
      font-size: 11px;
      color: #bdbdbd;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px dashed rgba(255,255,255,.25);
      background: rgba(255,255,255,.04);
      white-space: nowrap;
    }

    .hidden { display:none !important; }

    /* ===== Floating detachable player ===== */
    .floating-player {
      position: fixed;
      right: 12px;
      bottom: 12px;
      width: min(520px, calc(100vw - 24px));
      max-height: calc(100vh - 24px);
      overflow: auto;
      background: #181818;
      border: 1px solid #333;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.45);
      z-index: 9999;
    }
    .floating-bar {
      position: sticky;
      top: 0;
      background: #181818;
      padding: 8px 10px;
      border-bottom: 1px solid #2a2a2a;
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 8px;
    }
    .floating-title {
      font-size: 12px;
      font-weight: 600;
      color: #eee;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .floating-bar button {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #444;
      background: #262626;
      color: #eee;
      cursor: pointer;
    }
    .floating-bar button:hover { background:#333; }

    .floating-embed-wrap {
      padding: 10px;
    }

    .floating-embed-wrap iframe {
      width: 100%;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,0.22);
      background: #0f0f0f;
      display: block;
    }

    /* On smaller screens, dock player more centrally */
    @media (max-width: 700px) {
      .floating-player{
        left: 10px;
        right: 10px;
        bottom: 10px;
        width: auto;
        max-height: 60vh;
      }
    }

    /* ===== Next 10 Songs list ===== */
    .recent-songs { width:100%; overflow:auto; max-height:100%; padding: 6px 10px 10px; }
    .recent-table { width:100%; border-collapse: collapse; font-size: 12px; }
    .recent-table thead th {
      position: sticky; top: 0;
      background: rgba(20,20,20,0.95);
      color: #ddd;
      text-align: left;
      padding: 6px 6px;
      border-bottom: 1px solid rgba(255,255,255,0.12);
      white-space: nowrap;
      z-index: 2;
    }
    .recent-table tbody td {
      padding: 6px 6px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      vertical-align: top;
    }
    .recent-table tbody tr { cursor: pointer; }
    .recent-table tbody tr:hover { background: rgba(255,255,255,0.04); }
    .recent-table td:nth-child(1) { width: 54px; opacity: 0.9; }

    /* Next 10 Songs panel: slightly smaller fonts + padding that matches other tiles */
    #cell9 .cell-body { padding-left: 14px; padding-right: 14px; }
    #cell9 .cell-header { padding-left: 14px; padding-right: 14px; }
    #cell9 table { font-size: 12px; }
    #cell9 th { font-size: 11px; opacity: 0.9; }
    #cell9 td { padding-top: 6px; padding-bottom: 6px; }

    /* Tighten Next 10 Songs in denser layouts */
    @media (min-width: 600px) and (max-width: 1200px) {
      #cell9 .recent-table { font-size: 11px; }
      #cell9 td { padding-top: 4px; padding-bottom: 4px; }
      #cell9 .cell-body { max-height: 240px; overflow-y: auto; padding-left: 10px; padding-right: 10px; }
    }
  </style>
</head>

<body>
  <header>
    <h1>WXPN 885 Greatest Cover Songs – Countdown Dashboard</h1>
  </header>

  <div id="controls">
    <div id="controls-inner">
      <label for="frameSlider">Song number:</label>
      <input type="range" id="frameSlider" min="0" max="0" value="0" step="1" />
      <div id="frameLabel">0</div>
    </div>
  </div>

  <div id="dashboard">
    <!-- Current Song -->
    <div class="cell draggable-cell is-expanded" id="cell2">
      <div class="cell-header">
        <span class="cell-title">Current Song</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div id="current-song">
          <img id="current-album-art" src="" alt="" class="no-art" />
          <div class="song-title" id="current-song-title">Loading…</div>
          <div class="song-artist" id="current-song-artist"></div>
          <div class="song-meta" id="current-song-meta"></div>

          <div id="current-player-actions" class="player-actions">
            <button id="player-play-btn" type="button">Play</button>
            <span id="player-unavailable-msg" class="player-unavailable hidden"></span>
          </div>

          <div id="current-player-links" class="player-links"></div>
        </div>
      </div>
    </div>

    <!-- Next 10 Songs -->
    <div class="cell draggable-cell is-expanded" id="cell9">
      <div class="cell-header">
        <span class="cell-title">Next 10 Songs</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div class="recent-songs">
          <table class="recent-table">
            <thead><tr><th>Rank</th><th>Song</th><th>Artist</th><th>Original</th></tr></thead>
            <tbody id="recent-songs-body"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="cell draggable-cell is-expanded" id="cell1">
      <div class="cell-header">
        <span class="cell-title">Most Covered Original Artists</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body"><svg class="chart" id="chart-orig-artists"></svg></div>
    </div>

    <div class="cell draggable-cell is-expanded" id="cell3">
      <div class="cell-header">
        <span class="cell-title">Most Frequent Cover Artists</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body"><svg class="chart" id="chart-cover-artists"></svg></div>
    </div>

    <div class="cell draggable-cell is-expanded" id="cell4">
      <div class="cell-header">
        <span class="cell-title">Most Covered Original Years</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body"><svg class="chart" id="chart-orig-years"></svg></div>
    </div>

    <div class="cell draggable-cell is-expanded" id="cell5">
      <div class="cell-header">
        <span class="cell-title">Most Covered Original Decades</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body"><svg class="chart" id="chart-orig-decades"></svg></div>
    </div>

    <div class="cell draggable-cell is-expanded" id="cell6">
      <div class="cell-header">
        <span class="cell-title">Most Frequent Cover Years</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body"><svg class="chart" id="chart-cover-years"></svg></div>
    </div>

    <div class="cell draggable-cell is-expanded" id="cell7">
      <div class="cell-header">
        <span class="cell-title">Most Covered Original Songs</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body"><svg class="chart" id="chart-orig-songs"></svg></div>
    </div>

    <div class="cell draggable-cell is-expanded" id="cell8">
      <div class="cell-header">
        <span class="cell-title">Most Represented Genres</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body"><svg class="chart" id="chart-genres"></svg></div>
    </div>
  </div>

  <!-- Floating detachable player -->
  <div id="floating-player" class="floating-player hidden" aria-live="polite">
    <div class="floating-bar">
      <div class="floating-title" id="floating-title">Now Playing</div>
      <button id="player-close-btn" type="button">Close</button>
    </div>
    <div class="floating-embed-wrap">
      <div id="floating-player-embed"></div>
      <div id="floating-player-links" class="player-links"></div>
    </div>
  </div>

<script>
const urlParams = new URLSearchParams(window.location.search);
const DATA_ENDPOINT = urlParams.get("data_endpoint") || "data/2025_885_annotated.json";

const MIN_COUNT_ORIG_ARTIST = 2;
const MIN_COUNT_COVER_ARTIST = 2;
const MIN_COUNT_GENRE = 3;
const MIN_COUNT_ORIG_SONG = 2;
const MIN_COUNT_DECADE = 2;
const MIN_COUNT_ORIG_YEAR = 2;
const MIN_COUNT_COVER_YEAR = 2;

const MIN_DISPLAY_COUNT = 2;
const MOMENTUM_WINDOW = 20;
const FAST_RISER_THRESHOLD = 5;

const TOP_N_ARTISTS = 15;
const TOP_N_ORIG_SONGS = 15;
const TOP_N_GENRES = 20;
const TOP_N_DECADES = 10;
const TOP_N_YEARS = 15;

const MAX_LABEL_CHARS = 25;
const BAR_HEIGHT_FACTOR = 1/3;

const frameSlider = document.getElementById("frameSlider");
const frameLabel  = document.getElementById("frameLabel");

const currentAlbumArt  = document.getElementById("current-album-art");
const currentSongTitle = document.getElementById("current-song-title");
const currentSongArtist= document.getElementById("current-song-artist");
const currentSongMeta  = document.getElementById("current-song-meta");
const recentSongsBody = document.getElementById("recent-songs-body");
var rankToRow = {};
var rankToFrameIndex = {};

/* ===================== Player (on-demand, floating) ===================== */
(function () {
  if (window.Race2Player) return;

  // Player rate-limit hygiene:
  // - We NEVER change/reload the embedded iframe on slider changes.
  // - We only (re)create the iframe when the user presses Play.
  // This prevents rapid scrolling from triggering repeated embed loads (429s).
  var state = {
    open: false,
    // lastSong tracks the currently selected song (slider position)
    lastSong: null,
    // playingSong is the song whose embed is currently loaded/playing
    playingSong: null
  };

  function pickProvider(media) {
    if (!media) return null;

    var bc = media.bandcamp;
    if (bc && (bc.status === "manual" || bc.status === "found") && bc.embed_src) {
      return { key: "bandcamp", embed_src: bc.embed_src, height: 120 };
    }

    var sp = media.spotify;
    if (sp && sp.status === "found" && sp.embed_src) {
      return { key: "spotify", embed_src: sp.embed_src, height: 152 };
    }

    var dz = media.deezer;
    if (dz && dz.status === "found" && dz.embed_src) {
      return { key: "deezer", embed_src: dz.embed_src, height: 200 };
    }

    return null;
  }

  function setFloatingTitle(row) {
    var el = document.getElementById("floating-title");
    if (!el) return;
    var t = cleanLabelText((row && row.song) || "");
    var a = cleanLabelText((row && row.artist) || "");
    el.textContent = (t && a) ? (t + " — " + a) : "Now Playing";
  }

  function setAttachedAvailability(row) {
    var playBtn = document.getElementById("player-play-btn");
    var msg = document.getElementById("player-unavailable-msg");
    if (!playBtn || !msg) return;

    var provider = pickProvider(row && row.media);
    if (provider && provider.embed_src) {
      playBtn.classList.remove("hidden");
      playBtn.disabled = false;
      // If the currently selected song is the one already loaded in the floating
      // player, reflect that state. (Crucially, we still don't reload embeds on
      // slider changes; reload only happens when the user presses Play.)
      playBtn.textContent = (state.open && state.playingSong === row) ? "Playing" : "Play";
      msg.classList.add("hidden");
      msg.textContent = "";
    } else {
      playBtn.classList.add("hidden");
      msg.classList.remove("hidden");
      msg.textContent = "No preview available";
    }
  }

  function renderFloating(row) {
    var embedEl = document.getElementById("floating-player-embed");
    var linksEl = document.getElementById("floating-player-links");
    if (!embedEl || !linksEl) return;

    var provider = pickProvider(row && row.media);
    if (provider && provider.embed_src) {
      embedEl.innerHTML =
        '<iframe loading="lazy"' +
        ' src="' + provider.embed_src + '"' +
        ' style="width:100%;height:' + provider.height + 'px;border:0;border-radius:10px;margin-top:10px"' +
        ' allow="autoplay; encrypted-media; fullscreen; picture-in-picture"' +
        ' referrerpolicy="no-referrer"></iframe>';
    } else {
      embedEl.innerHTML = '<div class="song-meta" style="margin-top:10px;color:#aaa;">No embedded player available.</div>';
    }

    var m = (row && row.media) ? row.media : {};
    var links = [];
    if (m.spotify && m.spotify.url)  links.push('<a href="' + m.spotify.url + '">Open in Spotify</a>');
    if (m.deezer  && m.deezer.url)   links.push('<a href="' + m.deezer.url + '">Open in Deezer</a>');
    if (m.bandcamp && m.bandcamp.url) links.push('<a href="' + m.bandcamp.url + '">Support on Bandcamp</a>');
    linksEl.innerHTML = links.join("");
  }

  function open(row) {
    var floating = document.getElementById("floating-player");
    if (!floating) return;
    state.open = true;
    // Capture the song that is actually being played.
    state.playingSong = row;
    floating.classList.remove("hidden");
    setFloatingTitle(state.playingSong);
    renderFloating(state.playingSong);
  }

  function close() {
    var floating = document.getElementById("floating-player");
    if (!floating) return;
    state.open = false;
    floating.classList.add("hidden");
    var embedEl = document.getElementById("floating-player-embed");
    if (embedEl) embedEl.innerHTML = "";
    // Stop playback and clear the loaded embed.
    state.playingSong = null;
  }

  function play() {
    var row = state.lastSong;
    var provider = pickProvider(row && row.media);
    if (!provider || !provider.embed_src) return;
    open(row);
    var playBtn = document.getElementById("player-play-btn");
    if (playBtn) playBtn.textContent = "Playing";
  }

  function update(row) {
    state.lastSong = row;
    setAttachedAvailability(row);
    if (state.open) {
      // While the player is open, keep the embed locked to the song that was
      // playing when Play was pressed. Do not reload/recreate the iframe.
      // (We *only* change the embed when the user presses Play again.)
      setFloatingTitle(state.playingSong || row);
    }
  }

  window.Race2Player = { update: update, play: play, close: close };
})();

/* Wire player buttons (Safari compatible) */
document.addEventListener("click", function(e){
  if (!e || !e.target) return;
  if (e.target.id === "player-play-btn") {
    if (window.Race2Player && typeof window.Race2Player.play === "function") window.Race2Player.play();
  }
  if (e.target.id === "player-close-btn") {
    if (window.Race2Player && typeof window.Race2Player.close === "function") window.Race2Player.close();
    var playBtn = document.getElementById("player-play-btn");
    if (playBtn) playBtn.textContent = "Play";
  }
});

/* ===================== Helpers ===================== */
function truncateLabel(label, maxLen) {
  if (!label) return "";
  const s = String(label);
  if (s.length <= maxLen) return s;
  if (maxLen <= 1) return s.slice(0, maxLen);
  return s.slice(0, maxLen - 1) + "…";
}

function cleanLabelText(s) {
  return String(s || "").replace(/\\'/g, "'");
}

function renderUpcomingFromCurrent(currentRank) {
  if (!recentSongsBody) return;

  var rows = [];
  var cr = Number(currentRank || 0);
  if (!cr || isNaN(cr)) { recentSongsBody.innerHTML = ""; return; }
  if (cr >= 885) { recentSongsBody.innerHTML = ""; return; }

  var start = cr;
  var end = Math.min(885, cr + 9);

  for (var r = start; r <= end; r++) {
    var row = rankToRow[r];
    if (row) rows.push(row);
  }

  var htmlRows = [];
  for (var i=0; i<rows.length; i++) {
    var rr = rows[i];
    var rank = (rr.rank != null) ? String(rr.rank) : "";
    var song = rr.song ? cleanLabelText(rr.song) : "";
    var artist = rr.artist ? cleanLabelText(rr.artist) : "";
    var orig = rr.originalArtist ? cleanLabelText(rr.originalArtist) : "";
    htmlRows.push("<tr data-rank=\"" + rank + "\"><td>" + rank + "</td><td>" + song + "</td><td>" + artist + "</td><td>" + orig + "</td></tr>");
  }
  recentSongsBody.innerHTML = htmlRows.join("");
}

/* ===================== Main app state ===================== */
var initialized = false;
var sortedSongs = [];
var frameRanks = [];
var metrics = [];
var metricState = {};
var currentFrameIndex = 0;

function parseYearFromString(value) {
  if (value === null || value === undefined) return null;
  var m = String(value).match(/\b(18|19|20)\d{2}\b/);
  if (!m) return null;
  var year = parseInt(m[0], 10);
  if (isNaN(year) || year < 1800 || year > 2100) return null;
  return year;
}
function computeDecade(year) {
  if (year === null || year === undefined || isNaN(year)) return null;
  var y = parseInt(year, 10);
  return (Math.floor(y / 10) * 10) + "s";
}
function parsePhpGenre(value) {
  var s = String(value || "").trim();
  if (!s) return [];
  if (s.indexOf("a:") !== 0) return [];
  var regex = /s:\d+:"(.*?)"/g;
  var out = [];
  var m;
  while ((m = regex.exec(s)) !== null) out.push(m[1]);
  return out.map(function(x){ return String(x || "").trim(); }).filter(Boolean);
}
function parseGenreList(value) {
  var s = String(value || "").trim();
  if (!s) return [];
  var php = parsePhpGenre(s);
  if (php.length) return php;
  return [s];
}

const COLOR_PALETTE = [
  "#4e79a7","#f28e2b","#e15759","#76b7b2","#59a14f",
  "#edc948","#b07aa1","#ff9da7","#9c755f","#bab0ab",
  "#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3",
  "#fdb462","#b3de69","#fccde5","#d9d9d9","#bc80bd",
  "#ccebc5","#ffed6f"
];

function hashString(str) {
  var s = String(str || "");
  var h = 2166136261;
  for (var i=0; i<s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return (h >>> 0);
}
function colorForCategory(cat) {
  var idx = hashString(cat) % COLOR_PALETTE.length;
  return COLOR_PALETTE[idx];
}
function chooseTickStep(maxVal) {
  if (maxVal <= 20) return 2;
  if (maxVal <= 50) return 5;
  if (maxVal <= 250) return 25;
  if (maxVal <= 500) return 50;
  return 100;
}

function clearSvg(svg) {
  while (svg.firstChild) svg.removeChild(svg.firstChild);
}
function svgEl(tag, attrs) {
  var el = document.createElementNS("http://www.w3.org/2000/svg", tag);
  if (attrs) {
    Object.keys(attrs).forEach(function(k){ el.setAttribute(k, String(attrs[k])); });
  }
  return el;
}

function setupChart(svgElement, topN, globalMax, allowedSet) {
  var svg = svgElement;
  clearSvg(svg);

  var width = svg.clientWidth || 400;
  var height = svg.clientHeight || 240;

  var marginLeft;
  if (width <= 360) marginLeft = 90;
  else if (width <= 420) marginLeft = 105;
  else if (width <= 500) marginLeft = 115;
  else if (width <= 900) marginLeft = 150;
  else marginLeft = 165;

  var margin = { top: 4, right: 8, bottom: 18, left: marginLeft };
  var innerWidth = Math.max(10, width - margin.left - margin.right);
  var innerHeight = Math.max(10, height - margin.top - margin.bottom);

  svg.setAttribute("viewBox", "0 0 " + width + " " + height);

  var g = svgEl("g", { transform: "translate(" + margin.left + "," + margin.top + ")" });
  svg.appendChild(g);

  var maxVal = Math.max(globalMax || 2, 2);
  var step = chooseTickStep(maxVal);
  var xMaxRounded = Math.ceil(maxVal / step) * step;

  function xScale(v) {
    var vv = Math.max(0, Math.min(xMaxRounded, Number(v) || 0));
    return (vv / xMaxRounded) * innerWidth;
  }

  for (var t = 0; t <= xMaxRounded; t += step) {
    var x = xScale(t);
    var line = svgEl("line", {
      x1: x, y1: 0, x2: x, y2: innerHeight,
      stroke: "#333",
      "stroke-dasharray": "2,2"
    });
    g.appendChild(line);

    var tick = svgEl("text", {
      x: x, y: innerHeight + 14,
      fill: "#ccc",
      "font-size": "9",
      "text-anchor": "middle"
    });
    tick.textContent = String(t);
    g.appendChild(tick);
  }

  var slotHeight = innerHeight / topN;
  var barHeight = slotHeight * BAR_HEIGHT_FACTOR;

  return {
    svg: svg, g: g, innerWidth: innerWidth, innerHeight: innerHeight, xScale: xScale,
    slotHeight: slotHeight, barHeight: barHeight, topN: topN,
    allowed: allowedSet
  };
}

function updateChart(chart, frameCounts, prevFrameCounts, options) {
  var g = chart.g;
  var oldLayer = chart._layer;
  if (oldLayer && oldLayer.parentNode) oldLayer.parentNode.removeChild(oldLayer);
  var layer = svgEl("g");
  chart._layer = layer;
  g.appendChild(layer);

  var minDisplay = options.minDisplayCount;
  var fastThreshold = options.fastRiserThreshold;

  var entries = [];
  var fc = frameCounts || {};
  for (var k in fc) {
    var cat = k;
    var cnt = fc[k];
    if (!chart.allowed.has(cat)) continue;
    if (cnt == null || cnt < minDisplay) continue;
    entries.push([cat, cnt]);
  }

  entries.sort(function(a,b){
    return (b[1] - a[1]) || String(a[0]).localeCompare(String(b[0]));
  });

  var ordered = entries.slice(0, chart.topN);
  var count = ordered.length;
  if (!count) return;

  var startSlot = chart.topN - count;
  var slotPositions = [];
  for (var i=0; i<count; i++) {
    var slotIndex = startSlot + i;
    slotPositions.push(slotIndex * chart.slotHeight + (chart.slotHeight - chart.barHeight) / 2);
  }

  var fastSet = new Set();
  var pc = prevFrameCounts || {};
  for (var j=0; j<ordered.length; j++) {
    var cat2 = ordered[j][0];
    var val2 = ordered[j][1];
    var prevVal = pc[cat2] || 0;
    if ((val2 - prevVal) >= fastThreshold) fastSet.add(cat2);
  }

  for (var n=0; n<ordered.length; n++) {
    var cat3 = ordered[n][0];
    var val3 = ordered[n][1];
    var y = slotPositions[n];
    var w = chart.xScale(val3);

    var rect = svgEl("rect", { x: 0, y: y, width: w, height: chart.barHeight, fill: colorForCategory(cat3) });
    layer.appendChild(rect);

    var label = svgEl("text", {
      x: -6,
      y: y + chart.barHeight / 2,
      dy: "0.35em",
      fill: "#eee",
      "font-size": "10",
      "text-anchor": "end"
    });

    var base = String(cat3 || "");
    label.textContent = (fastSet.has(cat3) ? "↑ " : "") + truncateLabel(base, MAX_LABEL_CHARS);
    if (fastSet.has(cat3)) label.setAttribute("font-weight", "bold");

    var title = svgEl("title");
    title.textContent = base;
    label.appendChild(title);

    layer.appendChild(label);
  }
}

function computeGlobalMax(framesCounts, minDisplay) {
  var maxVal = 0;
  for (var i=0; i<framesCounts.length; i++) {
    var frame = framesCounts[i];
    if (!frame) continue;
    for (var k in frame) {
      var v = frame[k];
      if (v != null && v >= minDisplay && v > maxVal) maxVal = v;
    }
  }
  return maxVal;
}

function buildMetricTimeSeries(sortedRows, categoryFn, minCountFinal) {
  var finalCounts = new Map();
  for (var i=0; i<sortedRows.length; i++) {
    var row = sortedRows[i];
    var cats = categoryFn(row) || [];
    for (var j=0; j<cats.length; j++) {
      var cat = cats[j];
      if (cat === null || cat === undefined || String(cat).trim() === "") continue;
      var key = String(cat);
      finalCounts.set(key, (finalCounts.get(key) || 0) + 1);
    }
  }

  var allowed = new Set();
  finalCounts.forEach(function(cnt, key){
    if (cnt >= minCountFinal) allowed.add(key);
  });

  var frames = [];
  var currentCounts = new Map();

  for (var k=0; k<sortedRows.length; k++) {
    var row2 = sortedRows[k];
    var cats2 = categoryFn(row2) || [];
    for (var m=0; m<cats2.length; m++) {
      var key2 = String(cats2[m]);
      if (!allowed.has(key2)) continue;
      currentCounts.set(key2, (currentCounts.get(key2) || 0) + 1);
    }
    var snapshot = {};
    currentCounts.forEach(function(v2, kk){ snapshot[kk] = v2; });
    frames.push(snapshot);
  }

  return { frames: frames, allowed: allowed };
}

/* ===================== UI toggles / DnD ===================== */
function setCollapsed(cell, collapsed) {
  var btn = cell.querySelector(".cell-toggle");
  var body = cell.querySelector(".cell-body");
  if (!btn || !body) return;

  if (collapsed) {
    body.style.display = "none";
    cell.classList.add("is-collapsed");
    cell.classList.remove("is-expanded");
    btn.textContent = "Show";
  } else {
    body.style.display = "";
    cell.classList.remove("is-collapsed");
    cell.classList.add("is-expanded");
    btn.textContent = "Hide";
  }
}

function initCellToggles() {
  document.querySelectorAll(".cell").forEach(function(cell){
    var btn = cell.querySelector(".cell-toggle");
    var body = cell.querySelector(".cell-body");
    if (!btn || !body) return;

    cell.classList.add("is-expanded");
    cell.classList.remove("is-collapsed");

    btn.addEventListener("click", function(){
      var currentlyHidden = (body.style.display === "none");
      setCollapsed(cell, !currentlyHidden);
      if (initialized) rebuildChartsAndRedraw();
    });
  });
}

function initDragAndDrop() {
  var dashboard = document.getElementById("dashboard");
  var finePointer = window.matchMedia && window.matchMedia("(pointer: fine)").matches;
  if (!finePointer) return;

  var dragSrcEl = null;

  dashboard.querySelectorAll(".draggable-cell").forEach(function(cell){
    cell.setAttribute("draggable", "true");

    cell.addEventListener("dragstart", function(e){
      dragSrcEl = cell;
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setData("text/plain", "");
      cell.classList.add("dragging");
    });

    cell.addEventListener("dragend", function(){ cell.classList.remove("dragging"); });

    cell.addEventListener("dragover", function(e){
      e.preventDefault();
      if (!dragSrcEl || dragSrcEl === cell) return;

      var rect = cell.getBoundingClientRect();
      var offset = e.clientY - rect.top;
      var midpoint = rect.height / 2;
      if (offset > midpoint) dashboard.insertBefore(dragSrcEl, cell.nextSibling);
      else dashboard.insertBefore(dragSrcEl, cell);
    });
  });
}

function initKeyboardStepping() {
  window.addEventListener("keydown", function(e){
    var tag = (document.activeElement && document.activeElement.tagName) || "";
    if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT") return;

    if (e.key === "ArrowLeft") stepSlider(-1);
    if (e.key === "ArrowRight") stepSlider(1);
    if (e.key === "PageUp") stepSlider(-10);
    if (e.key === "PageDown") stepSlider(10);
  });
}

function initSwipeStepping() {
  var touchStartX = null;

  document.addEventListener("touchstart", function(e){
    if (!e.touches || !e.touches.length) return;
    touchStartX = e.touches[0].clientX;
  }, { passive: true });

  document.addEventListener("touchend", function(e){
    if (touchStartX === null) return;
    var endX = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : null;
    if (endX === null) return;

    var dx = endX - touchStartX;
    touchStartX = null;

    if (Math.abs(dx) < 40) return;
    if (dx > 0) stepSlider(-1);
    else stepSlider(1);
  }, { passive: true });
}

function initResizeHandler() {
  var t = null;
  window.addEventListener("resize", function(){
    if (!initialized) return;
    clearTimeout(t);
    t = setTimeout(function(){ rebuildChartsAndRedraw(); }, 80);
  });
}

function stepSlider(delta) {
  var min = Number(frameSlider.min);
  var max = Number(frameSlider.max);
  var cur = Number(frameSlider.value) || 0;
  var next = Math.max(min, Math.min(max, cur + delta));
  if (next !== cur) {
    frameSlider.value = String(next);
    frameSlider.dispatchEvent(new Event("input"));
  }
}

function rebuildChartsAndRedraw() {
  for (var i=0; i<metrics.length; i++) {
    var metric = metrics[i];
    var state = metricState[metric.id];
    var svgEl2 = document.getElementById(metric.svgId);
    if (!state || !svgEl2) continue;
    state.chart = setupChart(svgEl2, metric.topN, state.globalMax, state.allowed);
  }
  updateDashboard(currentFrameIndex);
}

/* ===================== Init + data load ===================== */
async function init() {
  initCellToggles();
  initDragAndDrop();
  initKeyboardStepping();
  initSwipeStepping();
  initResizeHandler();

  try {
    const resp = await fetch(DATA_ENDPOINT);
    if (!resp.ok) throw new Error("HTTP " + resp.status);
    const data = await resp.json();
    if (!Array.isArray(data)) throw new Error("Data endpoint must return an array");

    const raw = data.map(d => ({ ...d }));

    raw.forEach(row => {
      row.rank = (row.rank != null) ? Number(row.rank) : null;
      row.song = String(row.song || "").trim();
      row.artist = String(row.artist || "").trim();
      row.album = String(row.album || "").trim();
      row.albumArt = String(row.albumArt || "").trim();
      row.originalArtist = String(row.originalArtist || "").trim();
      row.originalYear = row.originalYear;
      row.releaseDate = row.releaseDate;
      row.genre_list = parseGenreList(row.genre);
      row.originalYear_parsed = parseYearFromString(row.originalYear);
      row.coverYear_parsed = parseYearFromString(row.releaseDate);
      row.originalDecade = computeDecade(row.originalYear_parsed);
      row.originalSongCombo = (row.song && row.originalArtist) ? (row.song + " — " + row.originalArtist) : null;
    });

    const filtered = raw.filter(row => row.rank != null && !isNaN(row.rank));

    if (!filtered.length) {
      frameLabel.textContent = "0";
      return;
    }

    sortedSongs = filtered.slice().sort((a,b) => (b.rank - a.rank));
    frameRanks = sortedSongs.map(r => r.rank);

    rankToRow = {};
    rankToFrameIndex = {};
    for (let i=0; i<sortedSongs.length; i++) {
      const r = sortedSongs[i];
      rankToRow[r.rank] = r;
      rankToFrameIndex[r.rank] = i;
    }

    metrics = [
      { id:"origArtists", svgId:"chart-orig-artists", categoryFn: row => row.originalArtist ? [String(row.originalArtist)] : [], minFinal: MIN_COUNT_ORIG_ARTIST, topN: TOP_N_ARTISTS },
      { id:"coverArtists", svgId:"chart-cover-artists", categoryFn: row => row.artist ? [String(row.artist)] : [], minFinal: MIN_COUNT_COVER_ARTIST, topN: TOP_N_ARTISTS },
      { id:"origYears", svgId:"chart-orig-years", categoryFn: row => row.originalYear_parsed ? [String(row.originalYear_parsed)] : [], minFinal: MIN_COUNT_ORIG_YEAR, topN: TOP_N_YEARS },
      { id:"origDecades", svgId:"chart-orig-decades", categoryFn: row => row.originalDecade ? [String(row.originalDecade)] : [], minFinal: MIN_COUNT_DECADE, topN: TOP_N_DECADES },
      { id:"coverYears", svgId:"chart-cover-years", categoryFn: row => row.coverYear_parsed ? [String(row.coverYear_parsed)] : [], minFinal: MIN_COUNT_COVER_YEAR, topN: TOP_N_YEARS },
      { id:"origSongs", svgId:"chart-orig-songs", categoryFn: row => row.originalSongCombo ? [String(row.originalSongCombo)] : [], minFinal: MIN_COUNT_ORIG_SONG, topN: TOP_N_ORIG_SONGS },
      { id:"genres", svgId:"chart-genres", categoryFn: row => row.genre_list || [], minFinal: MIN_COUNT_GENRE, topN: TOP_N_GENRES }
    ];

    metricState = {};
    for (let i=0; i<metrics.length; i++) {
      const metric = metrics[i];
      const built = buildMetricTimeSeries(sortedSongs, metric.categoryFn, metric.minFinal);
      const globalMax = computeGlobalMax(built.frames, MIN_DISPLAY_COUNT);
      const svgEl2 = document.getElementById(metric.svgId);
      const chart = svgEl2 ? setupChart(svgEl2, metric.topN, globalMax, built.allowed) : null;
      metricState[metric.id] = { frames: built.frames, allowed: built.allowed, globalMax: globalMax, chart: chart };
    }

    const numFrames = sortedSongs.length;
    frameSlider.min = 0;
    frameSlider.max = numFrames - 1;
    frameSlider.value = 0;
    currentFrameIndex = 0;

    frameSlider.addEventListener("input", e => {
      const idx = Number(e.target.value) || 0;
      updateDashboard(idx);
    });

    if (recentSongsBody) {
      recentSongsBody.addEventListener("click", function(ev) {
        var tr = ev.target && ev.target.closest ? ev.target.closest("tr") : null;
        if (!tr) return;
        var r = Number(tr.getAttribute("data-rank") || 0);
        if (!r || isNaN(r)) return;
        var idx2 = (rankToFrameIndex && (r in rankToFrameIndex)) ? rankToFrameIndex[r] : null;
        if (idx2 === null || idx2 === undefined) return;
        frameSlider.value = String(idx2);
        updateDashboard(idx2);
      });
    }

    initialized = true;
    updateDashboard(0);

  } catch (err) {
    console.error(err);
    frameLabel.textContent = "0";
    currentSongTitle.textContent = "Failed to load data";
  }
}

function updateDashboard(frameIndex) {
  if (!sortedSongs.length) return;

  const numFrames = sortedSongs.length;
  currentFrameIndex = Math.max(0, Math.min(numFrames - 1, frameIndex));

  const rank = frameRanks[currentFrameIndex];
  frameLabel.textContent = rank != null ? String(rank) : "";

  for (let i=0; i<metrics.length; i++) {
    const metric = metrics[i];
    const state = metricState[metric.id];
    if (!state || !state.chart) continue;

    const frameCounts = state.frames[currentFrameIndex] || {};
    const prevIndex = Math.max(0, currentFrameIndex - MOMENTUM_WINDOW);
    const prevCounts = state.frames[prevIndex] || {};

    updateChart(state.chart, frameCounts, prevCounts, { minDisplayCount: MIN_DISPLAY_COUNT, fastRiserThreshold: FAST_RISER_THRESHOLD });
  }

  const row = sortedSongs[currentFrameIndex];
  const imgUrl = String(row.albumArt || "").trim();

  if (imgUrl) {
    currentAlbumArt.classList.remove("no-art");
    currentAlbumArt.src = imgUrl;
    currentAlbumArt.alt = (row.song || "") + " – " + (row.artist || "");
  } else {
    currentAlbumArt.classList.add("no-art");
    currentAlbumArt.removeAttribute("src");
    currentAlbumArt.alt = "";
  }

  const title = row.song || "(Unknown song)";
  const artist = row.artist || "(Unknown cover artist)";
  const origArtist = row.originalArtist || "(Unknown original artist)";
  const origYear = row.originalYear_parsed ? String(row.originalYear_parsed) : "Unknown";
  const coverYear = row.coverYear_parsed ? String(row.coverYear_parsed) : "Unknown";

  currentSongTitle.textContent = title;
  currentSongArtist.textContent = artist + " (covering " + origArtist + ")";
  currentSongMeta.textContent = "Rank " + row.rank + " · Original year: " + origYear + " · Cover year: " + coverYear;

  renderUpcomingFromCurrent(row.rank);

  const linksEl = document.getElementById("current-player-links");
  if (linksEl) {
    const m = row.media || {};
    const links = [];
    if (m.spotify && m.spotify.url)  links.push('<a href="' + m.spotify.url + '">Spotify</a>');
    if (m.deezer  && m.deezer.url)   links.push('<a href="' + m.deezer.url + '">Deezer</a>');
    if (m.bandcamp && m.bandcamp.url) links.push('<a href="' + m.bandcamp.url + '">Bandcamp</a>');
    linksEl.innerHTML = links.join("");
  }

  if (window.Race2Player && typeof window.Race2Player.update === "function") window.Race2Player.update(row);
}

window.addEventListener("load", init);
</script>
</body>
</html>
