<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WXPN 885 Greatest Cover Songs – Countdown Dashboard</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      padding: 6px 0 2px;
      text-align: center;
    }
    header h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
      color: #f5f5f5;
    }

    #controls {
      padding: 4px 0 8px;
      background: #111;
      display: flex;
      justify-content: center;
    }
    #controls-inner {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #eee;
      max-width: 700px;
      width: 100%;
      padding: 4px 12px;
      border-radius: 999px;
      background: #222;
      border: 1px solid #333;
    }
    #controls-inner label {
      white-space: nowrap;
      font-size: 13px;
    }
    #frameLabel {
      min-width: 60px;
      text-align: right;
      font-variant-numeric: tabular-nums;
      font-size: 13px;
    }

    /* Finger-friendly slider */
    #frameSlider {
      flex: 1;
      height: 20px;
      -webkit-appearance: none;
      background: transparent;
      touch-action: pan-y; /* allow vertical scroll while still draggable */
    }
    #frameSlider::-webkit-slider-runnable-track {
      height: 6px;
      background: #444;
      border-radius: 999px;
    }
    #frameSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #eee;
      border: 2px solid #111;
      margin-top: -8px;
    }
    #frameSlider::-moz-range-track {
      height: 6px;
      background: #444;
      border-radius: 999px;
    }
    #frameSlider::-moz-range-thumb {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #eee;
      border: 2px solid #111;
    }

    /* Grid that can collapse tiles down to header-only */
    #dashboard {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-auto-rows: 42px;     /* base row unit */
      grid-auto-flow: dense;    /* pack collapsed tiles upward */
      gap: 6px;
      padding: 6px;
    }
    @media (max-width: 1200px) {
      #dashboard { grid-template-columns: repeat(2, 1fr); }
    }
    @media (max-width: 800px) {
      #dashboard { grid-template-columns: 1fr; }
    }

    .cell {
      background: #181818;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 4px 5px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      cursor: move;
      min-height: 0;
    }

    .cell.is-expanded { grid-row: span 8; }  /* tune tile height */
    .cell.is-collapsed { grid-row: span 1; padding-bottom: 0; }
    .cell.is-collapsed .cell-header { margin-bottom: 0; }

    .cell-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 2px;
    }
    .cell-title {
      flex: 1;
      font-size: 13px;
      font-weight: 600;
      color: #f0f0f0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: center;
    }
    .cell-toggle {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #444;
      background: #262626;
      color: #eee;
      cursor: pointer;
    }
    .cell-toggle:hover { background: #333; }

    .cell-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .chart-container {
      flex: 1;
      position: relative;
      min-height: 0;
    }
    svg.chart {
      width: 100%;
      height: 100%;
      display: block;
    }

    #current-song {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      gap: 8px;
      min-height: 0;
    }

    /* Fixed-height album-art to avoid layout jumps */
    #current-song img {
      max-width: 80%;
      height: 220px;
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0,0,0,0.7);
      object-fit: cover;
      background: #000;
      transition: opacity 0.2s ease-in-out;
    }
    #current-song img.no-art {
      opacity: 0;         /* keep reserved space */
      box-shadow: none;
    }

    #current-song .song-title {
      font-size: 15px;
      font-weight: 600;
    }
    #current-song .song-artist {
      font-size: 14px;
      color: #ccc;
    }
    #current-song .song-meta {
      font-size: 13px;
      color: #aaa;
    }

    .dragging {
      opacity: 0.6;
      outline: 2px dashed #888;
    }

    @media (pointer: coarse) {
      .cell { cursor: default; }
    }

    /* Mobile readability */
    @media (max-width: 800px) {
      header h1 { font-size: 18px; }
      .cell-title { font-size: 15px; }
      #controls-inner { padding: 6px 14px; }

      /* current song text */
      #current-song .song-title { font-size: 17px; }
      #current-song .song-artist { font-size: 15px; }
      #current-song .song-meta { font-size: 14px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>WXPN 885 Greatest Cover Songs – Countdown Dashboard</h1>
  </header>

  <div id="controls">
    <div id="controls-inner">
      <label for="frameSlider">Song number:</label>
      <input type="range" id="frameSlider" min="0" max="0" value="0" step="1" />
      <div id="frameLabel">0</div>
    </div>
  </div>

  <div id="dashboard">
    <div class="cell draggable-cell" id="cell1">
      <div class="cell-header">
        <span class="cell-title">Most Covered Original Artists</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div class="chart-container"><svg class="chart" id="chart-orig-artists"></svg></div>
      </div>
    </div>

    <div class="cell draggable-cell" id="cell2">
      <div class="cell-header">
        <span class="cell-title">Most Frequent Cover Artists</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div class="chart-container"><svg class="chart" id="chart-cover-artists"></svg></div>
      </div>
    </div>

    <div class="cell draggable-cell" id="cell3">
      <div class="cell-header">
        <span class="cell-title">Most Represented Genres</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div class="chart-container"><svg class="chart" id="chart-genres"></svg></div>
      </div>
    </div>

    <div class="cell draggable-cell" id="cell4">
      <div class="cell-header">
        <span class="cell-title">Most Covered Original Songs</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div class="chart-container"><svg class="chart" id="chart-orig-songs"></svg></div>
      </div>
    </div>

    <div class="cell draggable-cell" id="cell5">
      <div class="cell-header">
        <span class="cell-title">Most Covered Original Decades</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div class="chart-container"><svg class="chart" id="chart-orig-decades"></svg></div>
      </div>
    </div>

    <div class="cell draggable-cell" id="cell6">
      <div class="cell-header">
        <span class="cell-title">Current Song</span>
        <button class="cell-toggle" type="button">Hide</button>
      </div>
      <div class="cell-body">
        <div id="current-song">
          <img id="current-album-art" src="" alt="" class="no-art" />
          <div class="song-title" id="current-song-title">Loading…</div>
          <div class="song-artist" id="current-song-artist"></div>
          <div class="song-meta" id="current-song-meta"></div>
        </div>
      </div>
    </div>

    <!-- Slot 7: Cover years chart, collapsed by default -->
    <div class="cell draggable-cell" id="cell7">
      <div class="cell-header">
        <span class="cell-title">Most Frequent Cover Years</span>
        <button class="cell-toggle" type="button">Show</button>
      </div>
      <div class="cell-body" style="display: none;">
        <div class="chart-container"><svg class="chart" id="chart-cover-years"></svg></div>
      </div>
    </div>
  </div>

  <script>
    // --- Config ---------------------------------------------------------
    const MIN_COUNT_ORIG_ARTIST = 2;
    const MIN_COUNT_COVER_ARTIST = 2;
    const MIN_COUNT_GENRE = 3;
    const MIN_COUNT_ORIG_SONG = 2;
    const MIN_COUNT_DECADE = 2;
    const MIN_COUNT_COVER_YEAR = 2;

    const MIN_DISPLAY_COUNT = 2;
    const MOMENTUM_WINDOW = 20;
    const FAST_RISER_THRESHOLD = 5;

    const TOP_N_ARTISTS = 15;
    const TOP_N_ORIG_SONGS = 15;
    const TOP_N_GENRES = 20;
    const TOP_N_DECADES = 10;
    const TOP_N_YEARS = 15;

    const MAX_LABEL_CHARS = 25;
    const BAR_HEIGHT_FACTOR = 1 / 3;

    const frameSlider = document.getElementById("frameSlider");
    const frameLabel = document.getElementById("frameLabel");

    const currentAlbumArt = document.getElementById("current-album-art");
    const currentSongTitle = document.getElementById("current-song-title");
    const currentSongArtist = document.getElementById("current-song-artist");
    const currentSongMeta = document.getElementById("current-song-meta");

    const urlParams = new URLSearchParams(window.location.search);
    const DATA_ENDPOINT = urlParams.get("data_endpoint") || "https://origin.xpn.org/countdown/2025/json/cd2025.json";

    let sortedSongs = [];
    let frameRanks = [];
    let metrics = [];
    let metricState = {};
    let currentFrameIndex = 0;
    let initialized = false;

    function truncateLabel(label, maxLen) {
      if (!label) return "";
      if (label.length <= maxLen) return label;
      if (maxLen <= 1) return label.slice(0, maxLen);
      return label.slice(0, maxLen - 1) + "…";
    }

    function cleanLabelText(s) {
      return String(s || "").replace(/\\'/g, "'");
    }

    function parsePhpGenre(value) {
      if (!value || typeof value !== "string") return [];
      if (!value.startsWith("a:")) return [];
      const regex = /s:\d+:"(.*?)"/g;
      const result = [];
      let m;
      while ((m = regex.exec(value)) !== null) {
        result.push(m[1]);
      }
      return result;
    }

    // Conservative year parsing: takes first 4 chars if it's YYYY
    function parseYearFromString(value) {
      if (value === null || value === undefined) return null;
      const s = String(value).trim();
      if (s.length < 4) return null;
      const y = s.slice(0, 4);
      if (!/^\d{4}$/.test(y)) return null;
      const year = parseInt(y, 10);
      if (isNaN(year) || year < 1800 || year > 2100) return null;
      return year;
    }

    function computeDecade(year) {
      if (year === null || year === undefined || isNaN(year)) return null;
      const y = parseInt(year, 10);
      const decadeStart = Math.floor(y / 10) * 10;
      return decadeStart + "s";
    }

    function computeGlobalMax(framesCounts, minDisplay) {
      let maxVal = 0;
      framesCounts.forEach(frame => {
        Object.values(frame).forEach(v => {
          if (v != null && v >= minDisplay && v > maxVal) maxVal = v;
        });
      });
      return maxVal;
    }

    function buildMetricTimeSeries(sortedRows, categoryFn, minCountFinal) {
      const finalCounts = new Map();
      sortedRows.forEach(row => {
        const cats = categoryFn(row) || [];
        cats.forEach(cat => {
          if (cat === null || cat === undefined || cat === "") return;
          finalCounts.set(cat, (finalCounts.get(cat) || 0) + 1);
        });
      });

      const allowed = new Set(
        Array.from(finalCounts.entries())
          .filter(([, cnt]) => cnt >= minCountFinal)
          .map(([c]) => c)
      );

      const frames = [];
      const currentCounts = new Map();
      sortedRows.forEach(row => {
        const cats = categoryFn(row) || [];
        cats.forEach(cat => {
          if (!allowed.has(cat)) return;
          currentCounts.set(cat, (currentCounts.get(cat) || 0) + 1);
        });
        const snapshot = {};
        currentCounts.forEach((v, k) => { snapshot[k] = v; });
        frames.push(snapshot);
      });

      return { frames, allowed };
    }

    function chooseTickStep(maxVal) {
      if (maxVal <= 20) return 2;
      if (maxVal <= 50) return 5;
      if (maxVal <= 250) return 25;
      if (maxVal <= 500) return 50;
      return 100;
    }

    function setupChart(svgElement, topN, globalMax, allowedSet) {
      const svg = d3.select(svgElement);
      svg.selectAll("*").remove();

      const width = svg.node().clientWidth || 400;
      const height = svg.node().clientHeight || 200;

      let marginLeft;
      if (width <= 500) marginLeft = 130;
      else if (width <= 900) marginLeft = 150;
      else marginLeft = 165;

      const margin = { top: 4, right: 8, bottom: 18, left: marginLeft };
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      const g = svg
        .attr("viewBox", `0 0 ${width} ${height}`)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      const maxVal = Math.max(globalMax, 2);
      const step = chooseTickStep(maxVal);
      const xMaxRounded = Math.ceil(maxVal / step) * step;

      const xScale = d3.scaleLinear()
        .domain([0, xMaxRounded])
        .range([0, innerWidth]);

      const ticks = d3.range(0, xMaxRounded + step, step);

      const xAxisGrid = d3.axisBottom(xScale)
        .tickValues(ticks)
        .tickSize(-innerHeight)
        .tickFormat("");

      g.append("g")
        .attr("class", "x-grid")
        .attr("transform", `translate(0,${innerHeight})`)
        .call(xAxisGrid)
        .selectAll("line")
        .attr("stroke", "#333")
        .attr("stroke-dasharray", "2,2");

      const xAxis = d3.axisBottom(xScale)
        .tickValues(ticks)
        .tickFormat(d3.format("d"));

      g.append("g")
        .attr("class", "x-axis")
        .attr("transform", `translate(0,${innerHeight})`)
        .call(xAxis)
        .selectAll("text")
        .attr("fill", "#ccc")
        .attr("font-size", 9);

      // Make axis labels readable on mobile too
      // (we don't hardcode colors; just size)
      g.selectAll(".x-axis text").classed("x-axis-text", true);

      const slotHeight = innerHeight / topN;
      const barHeight = slotHeight * BAR_HEIGHT_FACTOR;

      // 20-ish distinct colors
      const colorRange = d3.schemeTableau10.concat(d3.schemeSet3);
      const domainCats = Array.from(allowedSet).sort((a, b) =>
        String(a).localeCompare(String(b))
      );
      const colorScale = d3.scaleOrdinal(colorRange).domain(domainCats);

      return { svg, g, innerWidth, innerHeight, xScale, slotHeight, barHeight, topN, colorScale };
    }

    function updateChart(chart, frameCounts, prevFrameCounts, allowedSet, labelFn, fullLabelFn, options) {
      const { slotHeight, barHeight, xScale, g, topN, colorScale } = chart;

      const minDisplay = options.minDisplayCount;
      const fastThreshold = options.fastRiserThreshold;

      const entries = Object.entries(frameCounts || {})
        .filter(([cat, cnt]) => allowedSet.has(cat) && cnt != null && cnt >= minDisplay);

      entries.sort((a, b) => d3.descending(a[1], b[1]));
      const ordered = entries.slice(0, topN);
      const count = ordered.length;

      if (count === 0) {
        g.selectAll("rect.bar").remove();
        g.selectAll("text.y-label").remove();
        return;
      }

      // bottom-up fill
      const startSlot = topN - count;
      const slotPositions = d3.range(count).map(i => {
        const slotIndex = startSlot + i;
        return slotIndex * slotHeight + (slotHeight - barHeight) / 2;
      });

      const fastSet = new Set();
      if (prevFrameCounts) {
        ordered.forEach(([cat, val]) => {
          const prevVal = prevFrameCounts[cat] || 0;
          const delta = val - prevVal;
          if (delta >= fastThreshold) fastSet.add(cat);
        });
      }

      const bars = g.selectAll("rect.bar").data(ordered, d => d[0]);

      bars.enter()
        .append("rect")
        .attr("class", "bar")
        .attr("x", 0)
        .attr("y", (d, i) => slotPositions[i])
        .attr("height", barHeight)
        .attr("width", d => xScale(d[1]))
        .attr("fill", d => colorScale(d[0]))
        .merge(bars)
        .attr("y", (d, i) => slotPositions[i])
        .attr("width", d => xScale(d[1]))
        .attr("fill", d => colorScale(d[0]));

      bars.exit().remove();

      const labels = g.selectAll("text.y-label").data(ordered, d => d[0]);

      const labelsEnter = labels.enter()
        .append("text")
        .attr("class", "y-label")
        .attr("x", -6)
        .attr("y", (d, i) => slotPositions[i] + barHeight / 2)
        .attr("dy", "0.35em")
        .attr("text-anchor", "end")
        .attr("alignment-baseline", "middle")
        .attr("fill", "#eee")
        .attr("font-size", 10);

      const labelsMerged = labelsEnter.merge(labels)
        .attr("y", (d, i) => slotPositions[i] + barHeight / 2)
        .text(d => {
          const cat = d[0];
          const base = labelFn(cat);
          const truncated = truncateLabel(base, MAX_LABEL_CHARS);
          return (fastSet.has(cat) ? "↑ " : "") + truncated;
        })
        .attr("font-weight", d => fastSet.has(d[0]) ? "bold" : "normal");

      labels.exit().remove();

      // Tooltip for full label where desired
      if (typeof fullLabelFn === "function") {
        labelsMerged.each(function(d) {
          const cat = d[0];
          const fullText = fullLabelFn(cat);
          const sel = d3.select(this);
          let title = sel.select("title");
          if (!fullText) {
            if (!title.empty()) title.remove();
            return;
          }
          if (title.empty()) title = sel.append("title");
          title.text(fullText);
        });
      } else {
        labelsMerged.select("title").remove();
      }
    }

    function labelDefault(cat) {
      if (cat === null || cat === undefined || cat === "") return "Unknown";
      return cleanLabelText(cat);
    }
    function labelDecade(cat) {
      if (cat === null || cat === undefined || cat === "") return "Unknown decade";
      return cleanLabelText(cat);
    }

    // --- Drag-and-drop (desktop only) -----------------------------------
    function initDragAndDrop() {
      const dashboard = document.getElementById("dashboard");
      const finePointer = window.matchMedia && window.matchMedia("(pointer: fine)").matches;
      if (!finePointer) return;

      let dragSrcEl = null;

      dashboard.querySelectorAll(".draggable-cell").forEach(cell => {
        cell.setAttribute("draggable", "true");

        cell.addEventListener("dragstart", e => {
          dragSrcEl = cell;
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/plain", "");
          cell.classList.add("dragging");
        });

        cell.addEventListener("dragend", () => {
          cell.classList.remove("dragging");
        });

        cell.addEventListener("dragover", e => {
          e.preventDefault();
          if (!dragSrcEl || dragSrcEl === cell) return;
          const rect = cell.getBoundingClientRect();
          const offset = e.clientY - rect.top;
          const midpoint = rect.height / 2;
          if (offset > midpoint) dashboard.insertBefore(dragSrcEl, cell.nextSibling);
          else dashboard.insertBefore(dragSrcEl, cell);
        });
      });
    }

    // --- Hide/show that collapses tile height ----------------------------
    function initCellToggles() {
      document.querySelectorAll(".cell").forEach(cell => {
        const btn = cell.querySelector(".cell-toggle");
        const body = cell.querySelector(".cell-body");
        if (!btn || !body) return;

        const initiallyHidden = body.style.display === "none";
        cell.classList.toggle("is-collapsed", initiallyHidden);
        cell.classList.toggle("is-expanded", !initiallyHidden);
        btn.textContent = initiallyHidden ? "Show" : "Hide";

        btn.addEventListener("click", () => {
          const isHidden = body.style.display === "none";
          body.style.display = isHidden ? "" : "none";

          cell.classList.toggle("is-collapsed", !isHidden);
          cell.classList.toggle("is-expanded", isHidden);

          btn.textContent = isHidden ? "Hide" : "Show";

          // layout changed; rebuild charts so widths/heights are correct
          if (initialized) rebuildChartsAndRedraw();
        });
      });
    }

    // --- Option A: one-song stepping ------------------------------------
    function stepSlider(delta) {
      const min = Number(frameSlider.min);
      const max = Number(frameSlider.max);
      const cur = Number(frameSlider.value) || 0;
      const next = Math.max(min, Math.min(max, cur + delta));
      if (next !== cur) {
        frameSlider.value = String(next);
        frameSlider.dispatchEvent(new Event("input"));
      }
    }

    function initKeyboardStepping() {
      window.addEventListener("keydown", (e) => {
        const tag = (document.activeElement && document.activeElement.tagName) || "";
        if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT") return;

        if (e.key === "ArrowLeft") stepSlider(-1);
        if (e.key === "ArrowRight") stepSlider(1);
        if (e.key === "PageUp") stepSlider(-10);
        if (e.key === "PageDown") stepSlider(10);
      });
    }

    function initSwipeStepping() {
      let touchStartX = null;

      document.addEventListener("touchstart", (e) => {
        if (!e.touches || !e.touches.length) return;
        touchStartX = e.touches[0].clientX;
      }, { passive: true });

      document.addEventListener("touchend", (e) => {
        if (touchStartX === null) return;
        const endX = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : null;
        if (endX === null) return;

        const dx = endX - touchStartX;
        touchStartX = null;

        // Only treat as swipe if intentional
        if (Math.abs(dx) < 40) return;

        if (dx > 0) stepSlider(-1); // swipe right = previous
        else stepSlider(1);         // swipe left  = next
      }, { passive: true });
    }

    // --- Rebuild charts on resize/layout change --------------------------
    function rebuildChartsAndRedraw() {
      // Recreate chart objects for current sizes
      metrics.forEach(metric => {
        const state = metricState[metric.id];
        const svgEl = document.getElementById(metric.svgId);
        if (!svgEl) return;

        // If the cell is collapsed, chart may be 0 height; still safe to build.
        state.chart = setupChart(svgEl, metric.topN, state.globalMax, state.allowed);
      });

      // Redraw current frame
      updateDashboard(currentFrameIndex);
    }

    function initResizeHandler() {
      let t = null;
      window.addEventListener("resize", () => {
        if (!initialized) return;
        clearTimeout(t);
        t = setTimeout(() => rebuildChartsAndRedraw(), 80);
      });
    }

    // --- Main ------------------------------------------------------------
    async function init() {
      initCellToggles();
      initDragAndDrop();
      initKeyboardStepping();
      initSwipeStepping();
      initResizeHandler();

      try {
        const resp = await fetch(DATA_ENDPOINT);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        if (!Array.isArray(data)) throw new Error("Data endpoint must return an array");

        const raw = data.map(d => ({ ...d }));
        raw.forEach(row => {
          row.rank = row.rank != null ? Number(row.rank) : null;
          row.genre_list = parsePhpGenre(row.genre);

          row.originalYear_parsed = row.originalYear != null ? Number(row.originalYear) : null;
          if (isNaN(row.originalYear_parsed)) row.originalYear_parsed = null;

          // cover year from releaseDate (your data samples: YYYY)
          row.coverYear_parsed = parseYearFromString(row.releaseDate);

          row.originalDecade = computeDecade(row.originalYear_parsed);

          const song = row.song || null;
          const oa = row.originalArtist || null;
          row.originalSongCombo = (song && oa) ? `${song} — ${oa}` : null;
        });

        const filtered = raw.filter(row => {
          if (row.rank == null || isNaN(row.rank)) return false;
          const hasArtist = row.artist != null && row.artist !== "";
          const hasOrigArtist = row.originalArtist != null && row.originalArtist !== "";
          return hasArtist || hasOrigArtist;
        });

        if (!filtered.length) {
          frameLabel.textContent = "0";
          return;
        }

        // ranks descending: 885 -> 1
        sortedSongs = filtered.slice().sort((a, b) => d3.descending(a.rank, b.rank));
        frameRanks = sortedSongs.map(row => row.rank);

        metrics = [
          {
            id: "origArtists",
            svgId: "chart-orig-artists",
            categoryFn: row => (row.originalArtist ? [row.originalArtist] : []),
            minFinal: MIN_COUNT_ORIG_ARTIST,
            topN: TOP_N_ARTISTS,
            labelFn: labelDefault,
            fullLabelFn: null
          },
          {
            id: "coverArtists",
            svgId: "chart-cover-artists",
            categoryFn: row => (row.artist ? [row.artist] : []),
            minFinal: MIN_COUNT_COVER_ARTIST,
            topN: TOP_N_ARTISTS,
            labelFn: labelDefault,
            fullLabelFn: null
          },
          {
            id: "genres",
            svgId: "chart-genres",
            categoryFn: row => row.genre_list || [],
            minFinal: MIN_COUNT_GENRE,
            topN: TOP_N_GENRES,
            labelFn: labelDefault,
            fullLabelFn: null
          },
          {
            id: "origSongs",
            svgId: "chart-orig-songs",
            categoryFn: row => (row.originalSongCombo ? [row.originalSongCombo] : []),
            minFinal: MIN_COUNT_ORIG_SONG,
            topN: TOP_N_ORIG_SONGS,
            labelFn: labelDefault,
            fullLabelFn: (cat) => cleanLabelText(cat) // tooltip full text
          },
          {
            id: "origDecades",
            svgId: "chart-orig-decades",
            categoryFn: row => (row.originalDecade ? [row.originalDecade] : []),
            minFinal: MIN_COUNT_DECADE,
            topN: TOP_N_DECADES,
            labelFn: labelDecade,
            fullLabelFn: null
          },
          {
            id: "coverYears",
            svgId: "chart-cover-years",
            categoryFn: row => (row.coverYear_parsed ? [row.coverYear_parsed] : []),
            minFinal: MIN_COUNT_COVER_YEAR,
            topN: TOP_N_YEARS,
            labelFn: labelDefault,
            fullLabelFn: null
          }
        ];

        metricState = {};

        metrics.forEach(metric => {
          const { frames, allowed } = buildMetricTimeSeries(sortedSongs, metric.categoryFn, metric.minFinal);
          const globalMax = computeGlobalMax(frames, MIN_DISPLAY_COUNT);

          const svgEl = document.getElementById(metric.svgId);
          const chart = svgEl ? setupChart(svgEl, metric.topN, globalMax, allowed) : null;

          metricState[metric.id] = {
            frames,
            allowed,
            globalMax,
            chart,
            labelFn: metric.labelFn,
            fullLabelFn: metric.fullLabelFn
          };
        });

        const numFrames = sortedSongs.length;
        frameSlider.min = 0;
        frameSlider.max = numFrames - 1;
        frameSlider.value = 0;
        currentFrameIndex = 0;

        frameSlider.addEventListener("input", e => {
          const idx = Number(e.target.value) || 0;
          updateDashboard(idx);
        });

        initialized = true;
        updateDashboard(0);

      } catch (err) {
        console.error(err);
        frameLabel.textContent = "0";
      }
    }

    function updateDashboard(frameIndex) {
      if (!sortedSongs.length) return;

      const numFrames = sortedSongs.length;
      currentFrameIndex = Math.max(0, Math.min(numFrames - 1, frameIndex));

      const rank = frameRanks[currentFrameIndex];
      frameLabel.textContent = rank != null ? String(rank) : "";

      metrics.forEach(metric => {
        const state = metricState[metric.id];
        if (!state || !state.chart) return;

        const frameCounts = state.frames[currentFrameIndex] || {};
        const prevIndex = Math.max(0, currentFrameIndex - MOMENTUM_WINDOW);
        const prevCounts = state.frames[prevIndex] || {};

        updateChart(
          state.chart,
          frameCounts,
          prevCounts,
          state.allowed,
          state.labelFn,
          state.fullLabelFn,
          {
            minDisplayCount: MIN_DISPLAY_COUNT,
            fastRiserThreshold: FAST_RISER_THRESHOLD
          }
        );
      });

      const songRow = sortedSongs[currentFrameIndex];
      const imgUrl = songRow.albumArt || "";

      if (imgUrl) {
        currentAlbumArt.classList.remove("no-art");
        currentAlbumArt.src = imgUrl;
        currentAlbumArt.alt = `${cleanLabelText(songRow.song || "")} – ${cleanLabelText(songRow.artist || "")}`;
      } else {
        currentAlbumArt.classList.add("no-art");
        currentAlbumArt.alt = "";
      }

      const title = cleanLabelText(songRow.song || "(Unknown song)");
      const artist = cleanLabelText(songRow.artist || "(Unknown cover artist)");
      const origArtist = cleanLabelText(songRow.originalArtist || "(Unknown original artist)");
      const origYear = songRow.originalYear_parsed || "Unknown year";
      const coverYear = songRow.coverYear_parsed || "Unknown cover year";

      currentSongTitle.textContent = title;
      currentSongArtist.textContent = `${artist} (covering ${origArtist})`;
      currentSongMeta.textContent = `Rank ${songRow.rank} · Original year: ${origYear} · Cover year: ${coverYear}`;
    }

    init();
  </script>
</body>
</html>
